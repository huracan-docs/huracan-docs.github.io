<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>huracan.engine API documentation</title>
<meta name="description" content="Huracan engine elements" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>huracan.engine</code></h1>
</header>
<section id="section-intro">
<h2 id="huracan-engine-elements">Huracan engine elements</h2>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># SPDX-FileCopyrightText: © 2021 Antonio López Rivera &lt;antonlopezr99@gmail.com&gt;
# SPDX-License-Identifier: GPL-3.0-only

&#34;&#34;&#34;
Huracan engine elements
-----------------------
&#34;&#34;&#34;

import re
import types
import numpy as np
from copy import deepcopy

from mpl_plotter import figure
from mpl_plotter.two_d import line, scatter, comparison
from mpl_plotter.color.schemes import colorscheme_one
from mpl_plotter.color.functions import delta

from alexandria.shell import print_color, print_result
from alexandria.data_structs.string import join_set_distance

from huracan.constants import R
from huracan.utils import markers


class component:
    &#34;&#34;&#34;
    Component
    ---------
    &#34;&#34;&#34;
    def __sub__(self, other):
        &#34;&#34;&#34;
        Stream creation operator: &lt;component&gt; - &lt;component&gt;
        &#34;&#34;&#34;
        if isinstance(other, component):
            s = stream()-other
            return s

    def __call__(self, gas):
        &#34;&#34;&#34;
        Component transfer function execution
        &#34;&#34;&#34;
        p = self.tf(gas)
        for k, v in p.__dict__.items():
            if k[-2:] == &#39;01&#39;:
                k = k[0] + &#39;0&#39;
            setattr(self, k, v)

        # Gas state variables
        for sv in [&#39;V&#39;, &#39;S&#39;, &#39;H&#39;]:
            setattr(self, sv, getattr(gas, sv))


class constructor_SET(type):
    &#34;&#34;&#34;
    Set metaclass
    -------------

    Ensure all necessary methods are implemented in child classes.
    &#34;&#34;&#34;
    def __new__(mcs, name, bases, body):

        for i in [&#39;add_component&#39;, &#39;add_set&#39;]:
            if name != mcs.__name__.split(&#39;_&#39;)[1] and i not in body:
                raise TypeError(f&#39;SET class build error: {i} method must be implemented in SET child classes.&#39;)

        return super().__new__(mcs, name, bases, body)


class constructor_SUPERSET(type):
    &#34;&#34;&#34;
    Superset metaclass
    ------------------

    Ensure all necessary methods are implemented in child classes.
    &#34;&#34;&#34;
    def __new__(mcs, name, bases, body):

        for i in [&#39;gobble&#39;]:
            if name != mcs.__name__.split(&#39;_&#39;)[1] and i not in body:
                if i not in body:
                    raise TypeError(f&#39;SUPERSET class build error: {i} method must be implemented in SUPERSET child classes.&#39;)

        return super().__new__(mcs, name, bases, body)


class SET(metaclass=constructor_SET):
    &#34;&#34;&#34;
    Component set class
    &#34;&#34;&#34;
    def __sub__(self, other):
        &#34;&#34;&#34;
        Set concatenation operator: &lt;set&gt; - &lt;component/set&gt;
        &#34;&#34;&#34;
        if isinstance(other, component):
            self.add_component(other)
            return self
        if isinstance(other, SET):
            return self.add_set(other)

    &#34;&#34;&#34;
    Superset takeover
    &#34;&#34;&#34;
    def superset_takeover(self):
        &#34;&#34;&#34;
        Superset takeover
        ---------------

        When a set (a stream) is integrated in a superset
        (a system), all set methods with a homonimous
        superset method are renamed as protected
        instance attributes, and their original names are
        taken by pointers to the homonimous superset methods.
        &#34;&#34;&#34;

        special = r&#39;^__(.*?)\__$&#39;

        def takeover(obj, method):
            if hasattr(obj.superset, method):
                return getattr(obj.superset, method)
            else:
                return getattr(obj, &#39;_&#39; + method)

        for k in dir(self):
            v = getattr(self, k)
            # If the attribute k is:
            #    - a method
            #    - which is not special
            #    - whose name is the name of another method in the stream&#39;s system
            if isinstance(v, types.MethodType) and not re.match(special, k) and k in dir(self.superset):
                if not hasattr(self, &#39;_&#39; + k):
                    # Create private method
                    setattr(self, &#39;_&#39; + k, v)
                # Replace public method by takeover
                setattr(self, k, takeover(self, k))


class SUPERSET(metaclass=constructor_SUPERSET):
    &#34;&#34;&#34;
    Component superset class
    &#34;&#34;&#34;
    def __call__(self, *args):
        &#34;&#34;&#34;
        Superset set addition operator: &lt;superset&gt;(&lt;list of sets&gt;)

        The gobble function must be implemented by the superset
        child class (system).

        :type args: set
        &#34;&#34;&#34;
        self.gobble(list(args))


class shaft:
    &#34;&#34;&#34;
    Shaft
    -----
    &#34;&#34;&#34;
    def __init__(self, *args, eta, eta_gearbox=1):
        &#34;&#34;&#34;
        :param args: list of components connected by the shaft.
        :param eta:  mechanical efficiency of the shaft.

        :type args:  component
        :type eta:   float
        &#34;&#34;&#34;
        self.eta         = eta
        self.eta_gearbox = eta_gearbox
        self.components  = list(args)

        for c in args:
            c.shaft = self

    def w_exerting_machinery(self):
        &#34;&#34;&#34;
        Return a list of all components in the shaft
        which exert work on the flow. That is, instances
        of the fan and compressor classes.
        &#34;&#34;&#34;
        return [c for c in self.components if c.__class__.__name__ in [&#39;fan&#39;,
                                                                       &#39;prop&#39;,
                                                                       &#39;propfan&#39;,
                                                                       &#39;compressor&#39;]]

    def electrical_plants(self):
        return [c for c in self.components if c.__class__.__name__ in [&#39;power_plant&#39;]]

    def w_r(self):
        &#34;&#34;&#34;
        Obtain the work required by the components which
        exert work on the gas (fan, compressors).
        &#34;&#34;&#34;
        wem = self.w_exerting_machinery()

        assert all([hasattr(c, &#39;w&#39;) for c in wem]), \
            &#34;The shaft&#39;s work exerting components do not have &#34; \
            &#34;a work attribute: ensure the streams to which each &#34; \
            &#34;belongs have been run up to the respective work &#34; \
            &#34;exerting component.&#34;

        work = np.array([c.w/self.eta_gearbox if c.__class__.__name__ in [&#39;fan&#39;, &#39;prop&#39;, &#39;propfan&#39;]
                         else c.w for c in wem])
        etas = np.array([c.shaft.eta for c in wem])
        w_r_m = np.sum(work/etas)                           # Power required by work exerting components

        electrical = self.electrical_plants()               # FIXME: ugly
        w_r_e = sum([c.w_r for c in electrical])            # Power required by all electrical plants

        return w_r_m + w_r_e


class stream(SET):
    &#34;&#34;&#34;
    Stream
    ------
    &#34;&#34;&#34;
    def __init__(self,
                 gas=None,
                 parents=None,
                 fr=None):
        &#34;&#34;&#34;
        :param fr:      Fraction of the gas instance passed
                        to the stream which physically enters
                        the stream.
                        This is useful so the original gas
                        instance can be passed to child streams
                        in a stream diversion process.
                        In this way, the gas attribute of the
                        child streams points to the original
                        stream&#39;s gas instance until the moment
                        the child streams are run: at this
                        time, a deep copy of the original gas
                        instance is created, and the mass flow
                        multiplied by _fr_ to reflect the mass
                        flow actually flowing in the child stream.
        :param parents: Parent streams.
                        - If parents includes 2 or more streams,
                          they will be merged at runtime.

        :type gas:     gas
        :type fr:      float
        :type parents: list of stream
        &#34;&#34;&#34;
        self.stream_id  = [0]
        self.components = []
        self.downstream = [self]

        self.ran = False

        if not isinstance(gas, type(None)):
            self.gas    = gas
        if not isinstance(parents, type(None)):
            self.parents = parents

        # Runtime dictionary
        self.runtime_d = {}
        if not isinstance(fr, type(None)):
            self.runtime_d[&#39;fr&#39;] = fr

    &#34;&#34;&#34;
    Operators
    &#34;&#34;&#34;
    def __call__(self, gas):
        self.gas = gas
        return self

    def __mul__(self, other):                       # TODO: stream diversion
        &#34;&#34;&#34;
        Stream diversion operator: &lt;stream&gt; * n     for n: 0 =&lt; float =&lt; 1
        &#34;&#34;&#34;
        return self.divert(other)

    def __getitem__(self, item):
        &#34;&#34;&#34;
        Component retrieval operator: &lt;stream&gt;[&lt;component stage name&gt;]
        &#34;&#34;&#34;
        return self.retrieve(item)

    &#34;&#34;&#34;
    Operator functions
    &#34;&#34;&#34;
    def add_component(self, c):
        &#34;&#34;&#34;
        Component addition
        &#34;&#34;&#34;
        self.components.append(c)
        c.downstream = self.downstream
        c.stream = c.set = self

    def add_set(self, s):
        &#34;&#34;&#34;
        Stream addition
        &#34;&#34;&#34;
        assert hasattr(self, &#39;gas&#39;) and hasattr(s, &#39;gas&#39;), &#39;Both streams must have a gas attribute for&#39; \
                                                           &#39;the stream merge operation to be possible.&#39;

        n = max(self.stream_id[0], s.stream_id[0])  # Get largest stream_id
        self.stream_id[0] = s.stream_id[0] = n      # Set largest stream_id for both merging streams

        merged = stream(parents=[self, s])
        merged.stream_id[0] = n + 1

        if hasattr(self, &#39;system&#39;) and hasattr(s, &#39;system&#39;):
            self.superset = self.system = s.system = merged.system = self.system + s.system
            self.system(merged)
        elif hasattr(self, &#39;system&#39;):
            self.system(s, merged)
        elif hasattr(s, &#39;system&#39;):
            s.system(self, merged)
        else:
            system(self, s, merged)

        return merged

    def divert(self, fr, names=None):
        &#34;&#34;&#34;
        Stream diversion
        &#34;&#34;&#34;

        assert hasattr(self, &#39;gas&#39;), &#39;The stream must have a gas attribute for&#39; \
                                     &#39;the stream diversion operation to be possible.&#39;

        main = stream(self.gas, fr=fr, parents=[self])
        div  = stream(self.gas, fr=1-fr, parents=[self])

        # Stream ID
        main.stream_id[0] = self.stream_id[0] + 1
        div.stream_id[0]  = self.stream_id[0] + 1

        # Diverted stream IDs
        if not isinstance(names, type(None)):
            main.stream_id.append(names[0])
            div.stream_id.append(names[1])
        else:
            mf_matrix = np.array([[main.gas.mf * fr,     main],
                                  [div.gas.mf  * (1-fr), div]])
            mf_matrix = mf_matrix[mf_matrix[:, 0].argsort()]

            for i in range(mf_matrix[:, 1].size):
                sub_id = &#39;m&#39; if i == 0 else f&#39;s{i}&#39; if i &gt; 1 else &#39;s&#39;
                mf_matrix[i, 1].stream_id.append(sub_id)

        if hasattr(self, &#39;system&#39;):
            self.system(main, div)
            main.system = div.system = self.system
        else:
            system(self, main, div)

        return main, div

    def retrieve(self, item):
        &#34;&#34;&#34;
        Retrieve any stream component by its stage name.

        :type item: str
        &#34;&#34;&#34;
        assert item in self.stages(), &#39;Specified a non-existent stage.&#39;

        for c in self.components:
            if c.stage == item:
                return c

    &#34;&#34;&#34;
    Utilities
    &#34;&#34;&#34;
    def stages(self):
        &#34;&#34;&#34;
        Return a list containing the stage name of each
        component in the stream.
        &#34;&#34;&#34;
        return [c.stage for c in self.components]

    def stage_name(self, c):
        &#34;&#34;&#34;
        Return the stage name of a component in the stream,
        composed of the stream identification number, a code
        representing its parent class, and a numerical index
        if there are more than 1 components of the same class
        in the stream.
        &#34;&#34;&#34;
        codes = {&#39;fan&#39;:                &#39;fn&#39;,
                 &#39;prop&#39;:               &#39;pr&#39;,
                 &#39;propfan&#39;:            &#39;pf&#39;,
                 &#39;intake&#39;:             &#39;it&#39;,
                 &#39;inlet&#39;:              &#39;il&#39;,
                 &#39;compressor&#39;:         &#39;cp&#39;,
                 &#39;combustion_chamber&#39;: &#39;cc&#39;,
                 &#39;turbine&#39;:            &#39;tb&#39;,
                 &#39;nozzle&#39;:             &#39;nz&#39;,

                 &#39;intercooler&#39;:        &#39;ic&#39;,
                 &#39;recuperator&#39;:        &#39;rc&#39;,
                 &#39;afterburner&#39;:        &#39;ab&#39;,
                 }

        code = codes[c.__class__.__name__] + self.n_instances(c)

        return f&#39;{&#34;.&#34;.join([str(c) for c in self.stream_id])}.{code}&#39;

    def n_instances(self, comp):
        &#34;&#34;&#34;
        Calculate the number of instances of a given component&#39;s
        parent class in the stream (n), and its index in the
        stream&#39;s components list (i).

        The index of the component is returned as follows:
        - If the given component is the only instance of its parent
          class in the stream (n = 1):
            - &#39;&#39;                                     (empty string)
        - If the given component is one of more instances of its
          parent class in the stream (n &gt; 1):
            - str(i + 1)                    (numeral starting at 1)

        :type comp: component
        &#34;&#34;&#34;

        i = 0       # Component index
        n = 0       # Number of instances of the input component&#39;s class in the stream
        for c in self.components:
            if comp is c:
                i = n
            if comp.__class__.__name__ == c.__class__.__name__:
                n += 1

        return &#39;&#39; if n == 1 else str(i + 1)

    def log(self):

        d = 9

        for c in self.components:
            section_name = join_set_distance(c.stage, c.__class__.__name__.capitalize().replace(&#34;_&#34;, &#34; &#34;), d)
            print_color(section_name, &#39;green&#39;)

            if c.__class__.__name__ == &#39;nozzle&#39;:
                if c.choked:
                    print_color(&#39; &#39;*d + &#39;Choked flow&#39;, &#39;red&#39;)
            print_result(&#39; &#39;*(d+1) + &#39;T0&#39;, c.t0, &#39;[K]&#39;)
            print_result(&#39; &#39;*(d+1) + &#39;p0&#39;, c.p0, &#39;[Pa]&#39;)

    &#34;&#34;&#34;
    Stream runtime functions
    &#34;&#34;&#34;
    def run(self, log=True):
        &#34;&#34;&#34;
        Execute the transfer functions of all components in the stream
        on the instance&#39;s gas class instance.
        &#34;&#34;&#34;

        self.runtime()

        assert hasattr(self, &#39;gas&#39;), &#39;stream does not have a gas attribute.&#39;

        self.choked = False                                 # FIXME: choked flow implementation is ugly

        for c in self.components:
            c(self.gas)                     # Run thermodynamic process on stream gas
            c.stage = self.stage_name(c)   # Set component stage name

            if hasattr(c, &#39;choked&#39;) and c.choked:           # FIXME: ugly
                self.choked = c.choked

        # Indicate stream has been run.
        self.ran = True

        if log:
            self.log()

    def runtime(self):
        if hasattr(self, &#39;parents&#39;) and len(self.parents) &gt; 1:
            self.merge()

        for k, v in self.runtime_d.items():
            f = getattr(self, k)
            f(v)

    def merge(self):
        if hasattr(self, &#39;gas&#39;):
            for s in self.parents:
                self.gas += s.gas
        else:
            self.gas = self.parents[0].gas
            for s in self.parents[1:]:
                self.gas += s.gas

    def fr(self, fr):
        self.gas, _ = fr * deepcopy(self.gas)

    &#34;&#34;&#34;
    Stream fluid state
    &#34;&#34;&#34;
    def t0(self):
        &#34;&#34;&#34;
        Total temperature vector.
        &#34;&#34;&#34;
        assert self.ran, &#39;The stream must be run to obtain the total temperature at each stage&#39;

        return np.array([c.t0 for c in self.components])

    def p0(self):
        &#34;&#34;&#34;
        Total pressure vector.
        &#34;&#34;&#34;
        assert self.ran, &#39;The stream must be run to obtain the total pressure at each stage&#39;

        return np.array([c.p0 for c in self.components])

    def V(self):
        &#34;&#34;&#34;
        Specific volume vector.
        &#34;&#34;&#34;
        assert self.ran, &#39;The stream must be run to obtain the specific volume at each stage&#39;

        return np.array([c.V for c in self.components])

    def S(self):
        &#34;&#34;&#34;
        Specific entropy vector.
        &#34;&#34;&#34;
        assert self.ran, &#39;The stream must be run to obtain the specific entropy at each stage&#39;

        return np.array([c.S for c in self.components])

    def H(self):
        &#34;&#34;&#34;
        Specific enthalpy vector.
        &#34;&#34;&#34;
        assert self.ran, &#39;The stream must be run to obtain the specific entropy at each stage&#39;

        return np.array([c.H for c in self.components])

    &#34;&#34;&#34;
    Stream outlet flow characteristics
    &#34;&#34;&#34;
    def v_exit(self):
        &#34;&#34;&#34;
        Flow exit velocity

        Assumptions:
        - If the flow is not choked:
             The thermal energy lost by the gas as it leaves the nozzle
             is transformed into kinetic energy without losses.
        - If the flow is choked:
             The exit velocity is the velocity of sound before the nozzle
             exit.
        &#34;&#34;&#34;
        # Absolute temperature before the stream exit (likely but not necessarily a nozzle)
        if len(self.components) &gt; 1:
            # If the stream has more components than 1, the absolute temperature
            # after the component previous to the last one is taken.
            if self.components[-1].__class__.__name__ == &#39;nozzle&#39;:
                t_before_exit = self.components[-2].t0
            else:
                t_before_exit = self.components[-1].t0
        else:
            if hasattr(self, &#39;parents&#39;):
                # If the stream has a single component and a parent stream or streams
                if len(self.parents) &gt; 1:
                    # If the stream has more than a single parent stream, the gases
                    # of each parent are copied, merged and the absolute temperature
                    # of the resulting gas mixture is taken.
                    for i in range(len(self.parents)):
                        if i == 0:
                            g = deepcopy(self.parents[i].gas)
                        else:
                            g += deepcopy(self.parents[i].gas)
                    t_before_exit = g.t0
                else:
                    # If the stream has a single parent, the absolute temperature
                    # of the parent&#39;s gas is taken.
                    t_before_exit = self.parents[0].gas.t0
            else:
                # Is the stream has a single component and no parent streams,
                # it is assumed that the setup consists of a intake-nozzle
                # setup, and the absolute temperature of the moving gas is
                # taken.
                t_before_exit = deepcopy(self.gas).absolute().t01

        if self.choked:
            return (self.gas.k(t_before_exit)*R*t_before_exit)**0.5         # M=1 immediately before nozzle exit
        else:
            assert t_before_exit - self.gas.t0 &gt; 0, &#39;The total temperature of the flow is lower before &#39; \
                                                    &#39;the nozzle tha outside the engine: this happens due to the &#39; \
                                                    &#39;compressors not providing enough energy to the flow. You must &#39; \
                                                    &#39;either increase the pressure ratio of the compressors or &#39; \
                                                    &#39;decrease the power extracted from the flow to solve the &#39; \
                                                    &#39;inconsistency.&#39;
            return (2*self.gas.cp(t_before_exit)*(t_before_exit - self.gas.t0))**0.5    # Heat -&gt; Kinetic energy

    def A_exit(self):
        &#34;&#34;&#34;
        Nozzle exit area
        &#34;&#34;&#34;
        return self.gas.mf*R*self.gas.t0/(self.gas.p0*self.v_exit())

    &#34;&#34;&#34;
    Fuel consumption
    &#34;&#34;&#34;
    def fmf(self):
        &#34;&#34;&#34;
        Stream fuel mass flow
        &#34;&#34;&#34;
        fmf = 0
        for c in self.components:
            if hasattr(c, &#39;fuel&#39;) and hasattr(c.fuel, &#39;mf&#39;):
                fmf += c.fuel.mf
        return fmf

    &#34;&#34;&#34;
    Thrust and specific fuel consumption
    &#34;&#34;&#34;
    def thrust_flow(self):
        &#34;&#34;&#34;
        Flow thrust

        If the flow is choked, the expansion of the gas contributes to the thrust of the flow.
        &#34;&#34;&#34;
        if self.choked:
            return self.gas.mf * (self.v_exit() - self.gas.v_0) + self.A_exit() * (
                        self.gas.p0 - self.gas.p_0)
        else:
            return self.gas.mf * (self.v_exit() - self.gas.v_0)

    def thrust_prop(self):
        &#34;&#34;&#34;
        Propeller/propfan thrust
        &#34;&#34;&#34;
        if any([c.__class__.__name__ in [&#39;prop&#39;, &#39;propfan&#39;] for c in self.components]):
            propellers = [c for c in self.components if c.__class__.__name__ in [&#39;prop&#39;, &#39;propfan&#39;]]
            thrust_prop = sum([prop.thrust(self.gas.v_0) for prop in propellers])
        else:
            thrust_prop = 0
        return thrust_prop

    def thrust_total(self):
        &#34;&#34;&#34;
        Flow thrust plus propeller/propfan thrust
        &#34;&#34;&#34;
        return self.thrust_flow() + self.thrust_prop()

    def sfc(self):
        &#34;&#34;&#34;
        Specific fuel consumption
        &#34;&#34;&#34;
        if hasattr(self, &#39;system&#39;):
            return self._fmf()/self._thrust_flow()
        else:
            return self.fmf()/self.thrust_flow()

    &#34;&#34;&#34;
    Heat and work
    &#34;&#34;&#34;
    def Q_in(self):                #TODO: verify efficiency calculations
        &#34;&#34;&#34;
        Heat provided to the flow.
        &#34;&#34;&#34;
        q_provided = 0
        for c in self.components:
            if c.__class__.__name__ == &#39;combustion_chamber&#39;:
                q_provided += c.Q
        return q_provided

    def W_req(self):
        &#34;&#34;&#34;
        Work required from the flow.
        &#34;&#34;&#34;
        w_required = 0
        for c in self.components:
            if c.__class__.__name__ in [&#39;fan&#39;,
                                        &#39;prop&#39;,
                                        &#39;propfan&#39;,
                                        &#39;compressor&#39;]:
                w_required += c.w
        return w_required

    &#34;&#34;&#34;
    Power
    &#34;&#34;&#34;
    def power_jet(self):
        &#34;&#34;&#34;
        Stream jet power.
        &#34;&#34;&#34;
        return 1/2*(self.gas.mf*self.v_exit()**2 - (self.gas.mf - self.fmf())*self.gas.v_0**2)

    def power_available(self):
        &#34;&#34;&#34;
        Stream available power.
        &#34;&#34;&#34;
        if hasattr(self, &#39;system&#39;):
            return self._efficiency_prop()*self._power_jet()
        else:
            return self.efficiency_prop()*self.power_jet()

    &#34;&#34;&#34;
    Efficiencies
    &#34;&#34;&#34;
    def efficiency_thermal(self):
        &#34;&#34;&#34;
        Stream thermal efficiency
        &#34;&#34;&#34;
        if hasattr(self, &#39;system&#39;):
            return self._power_jet()/self._Q_in()
        else:
            return self.power_jet()/self.Q_in()

    def efficiency_prop(self):
        &#34;&#34;&#34;
        Stream propulsive efficiency.
        &#34;&#34;&#34;
        return 2/(1+self.v_exit()/self.gas.v_0) if self.gas.v_0 &gt; 0 else 0

    def efficiency_total(self):
        if hasattr(self, &#39;system&#39;):
            return self._power_available()/self._Q_in()
        else:
            return self.power_available()/self.Q_in()

    &#34;&#34;&#34;
    Plots
    &#34;&#34;&#34;
    def plot_T_S(self,
             show=False,
             plot_label=None,
             color=colorscheme_one()[0],
             **kwargs):
        &#34;&#34;&#34;
        Temperature-Entropy stream plot.
        &#34;&#34;&#34;

        figure((9, 5))

        defaults = {&#39;x_label&#39;: &#39;$\Delta$S [kJ/K/n]&#39;,
                    &#39;y_label&#39;: &#39;T$_0$ [K]&#39;,}

        further_custom = {**defaults, **kwargs}

        self.plot_cycle_graph(self.S()/1000, self.t0(),
                              color=color,
                              plot_label=plot_label,
                              show=show,
                              # Further customization
                              y_tick_ndecimals=2,
                              **further_custom)

    def plot_p_V(self,
                 show=False,
                 plot_label=None,
                 color=colorscheme_one()[0],
                 **kwargs):
        &#34;&#34;&#34;
        Pressure-Volume stream plot.
        &#34;&#34;&#34;

        figure((9, 5))

        defaults = {&#39;x_label&#39;: &#39;v$_0$ [m$^3$/n]&#39;,
                    &#39;y_label&#39;: &#39;p$_0$ [kPa]&#39;}

        further_custom = {**defaults, **kwargs}

        self.plot_cycle_graph(self.V(), self.p0()/1000,
                              color=color,
                              plot_label=plot_label,
                              show=show,
                              # Further customization
                              y_tick_ndecimals=2,
                              **further_custom)

    def plot_H_p(self,
                 show=False,
                 plot_label=None,
                 color=colorscheme_one()[0],
                 **kwargs):
        &#34;&#34;&#34;
        Pressure-Enthalpy stream plot.
        &#34;&#34;&#34;

        figure((9, 5))

        defaults = {&#39;x_label&#39;: &#39;p$_0$ [kPa]&#39;,
                    &#39;y_label&#39;: &#39;H$_0$ [kJ]&#39;,}

        further_custom = {**defaults, **kwargs}

        self.plot_cycle_graph(self.p0()/1000, self.H()/1000,
                              color=color,
                              plot_label=plot_label,
                              show=show,
                              # Further customization
                              y_tick_ndecimals=2,
                              **further_custom)

    def plot_T_p(self,
             show=False,
             plot_label=None,
             color=colorscheme_one()[0],
             **kwargs):
        &#34;&#34;&#34;
        Temperature-Pressure system plot.
        &#34;&#34;&#34;

        figure((9, 5))

        defaults = {&#39;x_label&#39;: &#39;p$_0$ [kPa]&#39;,
                    &#39;y_label&#39;: &#39;T$_0$ [K]&#39;}

        further_custom = {**defaults, **kwargs}

        self.plot_cycle_graph(self.p0()/1000, self.t0(),
                              color=color,
                              plot_label=plot_label,
                              show=show,
                              # Further customization
                              x_tick_ndecimals=2,
                              **further_custom)

    def plot_cycle_graph(self,
                         x, y,
                         plot_label,
                         x_label, y_label,
                         color=colorscheme_one()[0],
                         show=False,
                         **kwargs
                         ):
        &#34;&#34;&#34;
        General plot composed of an MPL Plotter line and scatter plot.

        The default arguments plus any valid MPL Plotter line plotting
        class arguments can be passed to this function.
        &#34;&#34;&#34;
        fig = kwargs.pop(&#39;fig&#39;, None)

        defaults = {
            # Specifics
            &#39;point_size&#39;: 30,
            # Markers
            &#39;marker&#39;: &#39;x&#39;,
            # Color
            &#39;color&#39;: delta(color, -0.3),
            # Arrangement
            &#39;zorder&#39;: 2,
            # Further customization
            &#39;aspect&#39;: 1/2,
            &#39;x_tick_number&#39;: 10,
            &#39;y_tick_number&#39;: 10,
            &#39;demo_pad_plot&#39;: True,
            &#39;y_label_pad&#39;: 5,
        }

        further_custom = {**defaults, **kwargs}

        # Connecting lines
        line(   x=x, y=y,
                # Figure
                fig=fig,
                # Specifics
                line_width=1,
                # Color
                color=color, alpha=0.65,
                # Arrangement
                zorder=1,
                )
        # Stages
        scatter(x=x, y=y,
                # Figure
                fig=fig,
                # Further customization
                plot_label=plot_label,
                x_label=x_label,
                y_label=y_label,
                show=show,
                **further_custom)


class system(SUPERSET):
    &#34;&#34;&#34;
    System
    ------
    &#34;&#34;&#34;
    def __init__(self, *args):
        &#34;&#34;&#34;
        Create a system from two objects.

        :type args: stream
        &#34;&#34;&#34;
        self.streams = []
        self.gobble(list(args))

    &#34;&#34;&#34;
    Operators
    &#34;&#34;&#34;
    def __add__(self, other):
        &#34;&#34;&#34;
        System addition operator: &lt;system&gt; + &lt;stream/system&gt;

        :type other: system
        &#34;&#34;&#34;
        streams = list(set(self.streams) &amp; set(other.streams))
        return system(*streams)

    def __getitem__(self, item):
        &#34;&#34;&#34;
        Component retrieval operator: &lt;system&gt;[&lt;component stage name&gt;]
        &#34;&#34;&#34;
        return self.retrieve(item)

    &#34;&#34;&#34;
    Operator functions
    &#34;&#34;&#34;
    def gobble(self, streams):
        &#34;&#34;&#34;
        :type streams: list of stream
        &#34;&#34;&#34;
        for s in streams:
            self.streams.append(s)
            s.superset = s.system = self
            s.superset_takeover()

    def retrieve(self, item):
        &#34;&#34;&#34;
        Retrieve any stream component by its stage name.

        :type item: str
        &#34;&#34;&#34;
        components = []
        for s in self.streams:
            components += s.components

        assert item in [c.stage for c in components], &#39;Specified a non-existent stage.&#39;

        for c in components:
            if c.stage == item:
                return c

    &#34;&#34;&#34;
    System functions
    &#34;&#34;&#34;
    def run(self, log=True):
        &#34;&#34;&#34;
        Run stream system.
        &#34;&#34;&#34;

        self.sort_streams()

        n = 0
        while not all([s.ran for s in self.streams]):
            for s in self.streams:
                if s.stream_id[0] == n:
                    s._run(log)
            n += 1

    def sort_streams(self):
        &#34;&#34;&#34;
        Sort system streams based on their stream ID
        &#34;&#34;&#34;
        ids     = [&#39;&#39;.join(str(c) for c in stream.stream_id) for stream in self.streams]
        indexes = [float(id.replace(&#39;m&#39;, &#39;.1&#39;).replace(&#39;s&#39;, &#39;.2&#39;)) for id in ids]
        self.streams = [s for _, s in sorted(zip(indexes, self.streams))]

    def parents(self):
        &#34;&#34;&#34;
        Return all system streams with children.
        Useful to not calculate thrust, exit velocity
        and other stream outlet values for streams
        flowing to children streams.
        &#34;&#34;&#34;
        parents = []
        for s in self.streams:
            parents += s.parents if hasattr(s, &#39;parents&#39;) else []
        return parents

    &#34;&#34;&#34;
    Fuel consumption
    &#34;&#34;&#34;
    def fmf(self):
        &#34;&#34;&#34;
        System fuel mass flow.
        &#34;&#34;&#34;
        return sum([s._fmf() for s in self.streams])

    &#34;&#34;&#34;
    Thrust and specific fuel consumption
    &#34;&#34;&#34;
    def thrust_flow(self):
        &#34;&#34;&#34;
        System flow thrust.
        &#34;&#34;&#34;
        return sum([s._thrust_flow() for s in self.streams if s not in self.parents()])

    def thrust_prop(self):
        &#34;&#34;&#34;
        System propeller thrust
        &#34;&#34;&#34;
        return sum([s._thrust_prop() for s in self.streams])

    def thrust_total(self):
        &#34;&#34;&#34;
        System total thrust.
        &#34;&#34;&#34;
        return self.thrust_flow() + self.thrust_prop()

    def sfc(self):
        &#34;&#34;&#34;
        System specific fuel consumption.
        &#34;&#34;&#34;
        return self.fmf()/self.thrust_flow()

    &#34;&#34;&#34;
    Heat and work
    &#34;&#34;&#34;
    def Q_in(self):                 # TODO: verify efficiency calculations
        &#34;&#34;&#34;
        Heat provided to the flow.
        &#34;&#34;&#34;
        return sum([s._Q_in() for s in self.streams])

    def W_req(self):
        &#34;&#34;&#34;
        Work required from the flow.
        &#34;&#34;&#34;
        return sum([s._W_req() for s in self.streams])

    &#34;&#34;&#34;
    Power
    &#34;&#34;&#34;
    def power_jet(self):
        &#34;&#34;&#34;
        Stream jet power.
        &#34;&#34;&#34;
        return sum([s._power_jet() for s in self.streams if s not in self.parents()])

    def power_available(self):
        &#34;&#34;&#34;
        Stream available power.
        &#34;&#34;&#34;
        return sum([s._power_available() for s in self.streams if s not in self.parents()])

    &#34;&#34;&#34;
    Efficiencies
    &#34;&#34;&#34;
    def efficiency_prop(self):
        &#34;&#34;&#34;
        System propulsive efficiency.
        &#34;&#34;&#34;
        return self.power_available()/self.power_jet()

    def efficiency_thermal(self):
        &#34;&#34;&#34;
        System thermal efficiency.
        &#34;&#34;&#34;
        return self.power_jet()/self.Q_in()

    def efficiency_total(self):
        &#34;&#34;&#34;
        System total efficiency.
        &#34;&#34;&#34;
        return self.power_available()/self.Q_in()

    &#34;&#34;&#34;
    Plots
    &#34;&#34;&#34;
    def plot(self,
             x, y,
             x_scale=None, y_scale=None,
             x_label=None, y_label=None,
             show=False,
             plot_label=None,                  # When called from a _system_takeover the plot_label and color
             color=colorscheme_one()[0],       # arguments are passed to the function, but disregarded.
             colorblind=False,
             **kwargs):
        &#34;&#34;&#34;
        System plot
        -----------

        x and y are the stream parameters to be
        plotted for each stream.

        Process
        1. Create figure
        2. Create state variable and plotters vectors
            2.1 Parent connectors
        3. comparison call

        comparison call
            - fig=None, ax=None -&gt; plot_cycle_graph -&gt; fig in **kwargs keys
                - fig=None, ax=None -&gt; line, scatter
                    - line, scatter plot onto active figure, axis

        :param x_scale: Scaling factor.
        :param y_scale: Scaling factor.

        :type x:        str
        :type y:        str
        :type x_scale:  float
        :type y_scale:  float
        &#34;&#34;&#34;
        plotters   = []
        x_system   = []
        y_system   = []

        defaults   = {&#39;legend&#39;: kwargs.pop(&#39;legend&#39;, True)}

        scales     = {&#39;t0&#39;: 1,
                      &#39;p0&#39;: 1/1000,
                      &#39;V&#39;:  1,
                      &#39;S&#39;:  1/1000,
                      &#39;H&#39;:  1/1000}
        x_scale    = scales[x] if isinstance(x_scale, type(None)) else x_scale
        y_scale    = scales[y] if isinstance(y_scale, type(None)) else y_scale

        # 1. Create figure
        figure((9, 5))

        # 2. Create state variable and plotters vectors
        for stream in self.streams:

            # Plot defaults
            subplot_defaults = {
                &#39;plot_label&#39;: f&#39;{&#34;.&#34;.join([str(c) for c in stream.stream_id])}&#39;,
                &#39;x_label&#39;: x_label,
                &#39;y_label&#39;: y_label,
                &#39;color&#39;: colorscheme_one()[self.streams.index(stream)],
                &#39;zorder&#39;: self.streams.index(stream),
            }

            if colorblind:
                m      = markers(hollow=True)
                marker = m[self.streams.index(stream)]
                subplot_defaults = {**subplot_defaults, **marker}

            def gen_plotter(**defaults):
                &#34;&#34;&#34;
                Returns a plotter using the defaults.
                Any keyword arguemnts passed to the
                _plot function overwrite the defaults.
                &#34;&#34;&#34;
                return lambda x, y, **kwargs: stream.plot_cycle_graph(x=x, y=y, **{**defaults, **kwargs})

            x_stream = getattr(stream, x)()*x_scale
            y_stream = getattr(stream, y)()*y_scale

            plotters.append(gen_plotter(**subplot_defaults))
            x_system.append(x_stream)
            y_system.append(y_stream)

            # 2.1 Parent connectors
            if hasattr(stream, &#39;parents&#39;):
                for parent in stream.parents:
                    x_parent = getattr(parent, x)()*x_scale
                    y_parent = getattr(parent, y)()*y_scale
                    # If the parent stream has no stages, get parent stream&#39;s gas state
                    p_x = x_parent[-1] if len(x_parent) != 0 else getattr(parent.gas, x)*x_scale
                    p_y = y_parent[-1] if len(y_parent) != 0 else getattr(parent.gas, y)*y_scale
                    # Connector
                    if len(stream.components) &gt; 0:
                        x_system.append(np.array([p_x, x_stream[0]]))
                        y_system.append(np.array([p_y, y_stream[0]]))

                        connector_args = {&#39;color&#39;: subplot_defaults[&#39;color&#39;],
                                          &#39;zorder&#39;: self.streams.index(stream),
                                          &#39;plot_label&#39;: None,
                                          &#39;x_label&#39;: None,
                                          &#39;y_label&#39;: None,
                                          &#39;marker&#39;: &#39;&#39;
                                          }

                        if colorblind:
                            connector_args = {**connector_args}

                        plotters.append(gen_plotter(**connector_args))

        # 2.2 Remove streams with no stages
        mask_x = np.array([a.size != 0 for a in x_system])
        mask_y = np.array([a.size != 0 for a in y_system])
        mask = mask_x * mask_y  # Ensure that any x-y array pairs with an empty array are removed

        x_system = np.array(x_system, dtype=&#39;object&#39;)[mask].tolist()
        y_system = np.array(y_system, dtype=&#39;object&#39;)[mask].tolist()
        plotters = np.array(plotters, dtype=&#39;object&#39;)[mask].tolist()

        # 4. comparison call
        #     - fig=None, ax=None -&gt; plot_cycle_graph -&gt; fig in **kwargs keys
        #         - fig=None, ax=None -&gt; line, scatter
        #             - line, scatter plot onto active figure, axis
        comparison(x=x_system,
                   y=y_system,
                   f=plotters,
                   legend_loc=(0.865, 0.425),
                   autocolor=False,
                   show=show,
                   **{**kwargs, **defaults})

    def plot_T_p(self,
                 show=False,
                 plot_label=None,
                 color=colorscheme_one()[0],
                 colorblind=False,
                 **kwargs
                 ):
        &#34;&#34;&#34;
        Temperature-Pressure system plot.
        &#34;&#34;&#34;
        args = locals()
        args.pop(&#39;self&#39;, None)
        args.pop(&#39;kwargs&#39;, None)

        self.plot(x=&#39;p0&#39;, x_label=&#39;p$_0$ [kPa]&#39;,
                  y=&#39;t0&#39;, y_label=&#39;T$_0$ [K]&#39;,
                  **{**args, **kwargs})

    def plot_p_V(self,
                 show=False,
                 plot_label=None,
                 color=colorscheme_one()[0],
                 colorblind=False,
                 **kwargs):
        &#34;&#34;&#34;
        Pressure-Volume system plot.
        &#34;&#34;&#34;
        args = locals()
        args.pop(&#39;self&#39;, None)
        args.pop(&#39;kwargs&#39;, None)

        self.plot(x=&#39;V&#39;,  x_label=&#39;v$_0$ [m$^3$/n]&#39;,
                  y=&#39;p0&#39;, y_label=&#39;p$_0$ [kPa]&#39;,
                  **{**args, **kwargs})

    def plot_T_S(self,
                 show=False,
                 plot_label=None,
                 color=colorscheme_one()[0],
                 colorblind=False,
                 **kwargs):
        &#34;&#34;&#34;
        Temperature-Entropy system plot.
        &#34;&#34;&#34;
        args = locals()
        args.pop(&#39;self&#39;, None)
        args.pop(&#39;kwargs&#39;, None)

        self.plot(x=&#39;S&#39;,  x_label=&#39;$\Delta$S [kJ/K]&#39;,
                  y=&#39;t0&#39;, y_label=&#39;T$_0$ [K]&#39;,
                  **{**args, **kwargs})

    def plot_H_p(self,
                 show=False,
                 plot_label=None,
                 color=colorscheme_one()[0],
                 colorblind=False,
                 **kwargs):
        &#34;&#34;&#34;
        Pressure-Enthalpy system plot.
        &#34;&#34;&#34;
        args = locals()
        args.pop(&#39;self&#39;, None)
        args.pop(&#39;kwargs&#39;, None)

        self.plot(x=&#39;p0&#39;, x_label=&#39;p$_0$ [kPa]&#39;,
                  y=&#39;H&#39;,  y_label=&#39;H$_0$ [kJ]&#39;,
                  **{**args, **kwargs})</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="huracan.engine.SET"><code class="flex name class">
<span>class <span class="ident">SET</span></span>
</code></dt>
<dd>
<div class="desc"><p>Component set class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SET(metaclass=constructor_SET):
    &#34;&#34;&#34;
    Component set class
    &#34;&#34;&#34;
    def __sub__(self, other):
        &#34;&#34;&#34;
        Set concatenation operator: &lt;set&gt; - &lt;component/set&gt;
        &#34;&#34;&#34;
        if isinstance(other, component):
            self.add_component(other)
            return self
        if isinstance(other, SET):
            return self.add_set(other)

    &#34;&#34;&#34;
    Superset takeover
    &#34;&#34;&#34;
    def superset_takeover(self):
        &#34;&#34;&#34;
        Superset takeover
        ---------------

        When a set (a stream) is integrated in a superset
        (a system), all set methods with a homonimous
        superset method are renamed as protected
        instance attributes, and their original names are
        taken by pointers to the homonimous superset methods.
        &#34;&#34;&#34;

        special = r&#39;^__(.*?)\__$&#39;

        def takeover(obj, method):
            if hasattr(obj.superset, method):
                return getattr(obj.superset, method)
            else:
                return getattr(obj, &#39;_&#39; + method)

        for k in dir(self):
            v = getattr(self, k)
            # If the attribute k is:
            #    - a method
            #    - which is not special
            #    - whose name is the name of another method in the stream&#39;s system
            if isinstance(v, types.MethodType) and not re.match(special, k) and k in dir(self.superset):
                if not hasattr(self, &#39;_&#39; + k):
                    # Create private method
                    setattr(self, &#39;_&#39; + k, v)
                # Replace public method by takeover
                setattr(self, k, takeover(self, k))</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="huracan.engine.stream" href="#huracan.engine.stream">stream</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="huracan.engine.SET.superset_takeover"><code class="name flex">
<span>def <span class="ident">superset_takeover</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="superset-takeover">Superset Takeover</h2>
<p>When a set (a stream) is integrated in a superset
(a system), all set methods with a homonimous
superset method are renamed as protected
instance attributes, and their original names are
taken by pointers to the homonimous superset methods.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def superset_takeover(self):
    &#34;&#34;&#34;
    Superset takeover
    ---------------

    When a set (a stream) is integrated in a superset
    (a system), all set methods with a homonimous
    superset method are renamed as protected
    instance attributes, and their original names are
    taken by pointers to the homonimous superset methods.
    &#34;&#34;&#34;

    special = r&#39;^__(.*?)\__$&#39;

    def takeover(obj, method):
        if hasattr(obj.superset, method):
            return getattr(obj.superset, method)
        else:
            return getattr(obj, &#39;_&#39; + method)

    for k in dir(self):
        v = getattr(self, k)
        # If the attribute k is:
        #    - a method
        #    - which is not special
        #    - whose name is the name of another method in the stream&#39;s system
        if isinstance(v, types.MethodType) and not re.match(special, k) and k in dir(self.superset):
            if not hasattr(self, &#39;_&#39; + k):
                # Create private method
                setattr(self, &#39;_&#39; + k, v)
            # Replace public method by takeover
            setattr(self, k, takeover(self, k))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="huracan.engine.SUPERSET"><code class="flex name class">
<span>class <span class="ident">SUPERSET</span></span>
</code></dt>
<dd>
<div class="desc"><p>Component superset class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SUPERSET(metaclass=constructor_SUPERSET):
    &#34;&#34;&#34;
    Component superset class
    &#34;&#34;&#34;
    def __call__(self, *args):
        &#34;&#34;&#34;
        Superset set addition operator: &lt;superset&gt;(&lt;list of sets&gt;)

        The gobble function must be implemented by the superset
        child class (system).

        :type args: set
        &#34;&#34;&#34;
        self.gobble(list(args))</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="huracan.engine.system" href="#huracan.engine.system">system</a></li>
</ul>
</dd>
<dt id="huracan.engine.component"><code class="flex name class">
<span>class <span class="ident">component</span></span>
</code></dt>
<dd>
<div class="desc"><h2 id="component">Component</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class component:
    &#34;&#34;&#34;
    Component
    ---------
    &#34;&#34;&#34;
    def __sub__(self, other):
        &#34;&#34;&#34;
        Stream creation operator: &lt;component&gt; - &lt;component&gt;
        &#34;&#34;&#34;
        if isinstance(other, component):
            s = stream()-other
            return s

    def __call__(self, gas):
        &#34;&#34;&#34;
        Component transfer function execution
        &#34;&#34;&#34;
        p = self.tf(gas)
        for k, v in p.__dict__.items():
            if k[-2:] == &#39;01&#39;:
                k = k[0] + &#39;0&#39;
            setattr(self, k, v)

        # Gas state variables
        for sv in [&#39;V&#39;, &#39;S&#39;, &#39;H&#39;]:
            setattr(self, sv, getattr(gas, sv))</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="huracan.components.heat_exchangers.heat_sink" href="components/heat_exchangers.html#huracan.components.heat_exchangers.heat_sink">heat_sink</a></li>
<li><a title="huracan.components.power.combustion.combustor" href="components/power/combustion.html#huracan.components.power.combustion.combustor">combustor</a></li>
<li><a title="huracan.components.power.sinks.electrical_system" href="components/power/sinks.html#huracan.components.power.sinks.electrical_system">electrical_system</a></li>
<li><a title="huracan.components.rotary.screw" href="components/rotary.html#huracan.components.rotary.screw">screw</a></li>
<li><a title="huracan.components.static.intake" href="components/static.html#huracan.components.static.intake">intake</a></li>
<li><a title="huracan.components.static.nozzle" href="components/static.html#huracan.components.static.nozzle">nozzle</a></li>
</ul>
</dd>
<dt id="huracan.engine.constructor_SET"><code class="flex name class">
<span>class <span class="ident">constructor_SET</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="set-metaclass">Set Metaclass</h2>
<p>Ensure all necessary methods are implemented in child classes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class constructor_SET(type):
    &#34;&#34;&#34;
    Set metaclass
    -------------

    Ensure all necessary methods are implemented in child classes.
    &#34;&#34;&#34;
    def __new__(mcs, name, bases, body):

        for i in [&#39;add_component&#39;, &#39;add_set&#39;]:
            if name != mcs.__name__.split(&#39;_&#39;)[1] and i not in body:
                raise TypeError(f&#39;SET class build error: {i} method must be implemented in SET child classes.&#39;)

        return super().__new__(mcs, name, bases, body)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.type</li>
</ul>
</dd>
<dt id="huracan.engine.constructor_SUPERSET"><code class="flex name class">
<span>class <span class="ident">constructor_SUPERSET</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="superset-metaclass">Superset Metaclass</h2>
<p>Ensure all necessary methods are implemented in child classes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class constructor_SUPERSET(type):
    &#34;&#34;&#34;
    Superset metaclass
    ------------------

    Ensure all necessary methods are implemented in child classes.
    &#34;&#34;&#34;
    def __new__(mcs, name, bases, body):

        for i in [&#39;gobble&#39;]:
            if name != mcs.__name__.split(&#39;_&#39;)[1] and i not in body:
                if i not in body:
                    raise TypeError(f&#39;SUPERSET class build error: {i} method must be implemented in SUPERSET child classes.&#39;)

        return super().__new__(mcs, name, bases, body)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.type</li>
</ul>
</dd>
<dt id="huracan.engine.shaft"><code class="flex name class">
<span>class <span class="ident">shaft</span></span>
<span>(</span><span>*args, eta, eta_gearbox=1)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="shaft">Shaft</h2>
<p>:param args: list of components connected by the shaft.
:param eta:
mechanical efficiency of the shaft.</p>
<p>:type args:
component
:type eta:
float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class shaft:
    &#34;&#34;&#34;
    Shaft
    -----
    &#34;&#34;&#34;
    def __init__(self, *args, eta, eta_gearbox=1):
        &#34;&#34;&#34;
        :param args: list of components connected by the shaft.
        :param eta:  mechanical efficiency of the shaft.

        :type args:  component
        :type eta:   float
        &#34;&#34;&#34;
        self.eta         = eta
        self.eta_gearbox = eta_gearbox
        self.components  = list(args)

        for c in args:
            c.shaft = self

    def w_exerting_machinery(self):
        &#34;&#34;&#34;
        Return a list of all components in the shaft
        which exert work on the flow. That is, instances
        of the fan and compressor classes.
        &#34;&#34;&#34;
        return [c for c in self.components if c.__class__.__name__ in [&#39;fan&#39;,
                                                                       &#39;prop&#39;,
                                                                       &#39;propfan&#39;,
                                                                       &#39;compressor&#39;]]

    def electrical_plants(self):
        return [c for c in self.components if c.__class__.__name__ in [&#39;power_plant&#39;]]

    def w_r(self):
        &#34;&#34;&#34;
        Obtain the work required by the components which
        exert work on the gas (fan, compressors).
        &#34;&#34;&#34;
        wem = self.w_exerting_machinery()

        assert all([hasattr(c, &#39;w&#39;) for c in wem]), \
            &#34;The shaft&#39;s work exerting components do not have &#34; \
            &#34;a work attribute: ensure the streams to which each &#34; \
            &#34;belongs have been run up to the respective work &#34; \
            &#34;exerting component.&#34;

        work = np.array([c.w/self.eta_gearbox if c.__class__.__name__ in [&#39;fan&#39;, &#39;prop&#39;, &#39;propfan&#39;]
                         else c.w for c in wem])
        etas = np.array([c.shaft.eta for c in wem])
        w_r_m = np.sum(work/etas)                           # Power required by work exerting components

        electrical = self.electrical_plants()               # FIXME: ugly
        w_r_e = sum([c.w_r for c in electrical])            # Power required by all electrical plants

        return w_r_m + w_r_e</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="huracan.engine.shaft.electrical_plants"><code class="name flex">
<span>def <span class="ident">electrical_plants</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def electrical_plants(self):
    return [c for c in self.components if c.__class__.__name__ in [&#39;power_plant&#39;]]</code></pre>
</details>
</dd>
<dt id="huracan.engine.shaft.w_exerting_machinery"><code class="name flex">
<span>def <span class="ident">w_exerting_machinery</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of all components in the shaft
which exert work on the flow. That is, instances
of the fan and compressor classes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def w_exerting_machinery(self):
    &#34;&#34;&#34;
    Return a list of all components in the shaft
    which exert work on the flow. That is, instances
    of the fan and compressor classes.
    &#34;&#34;&#34;
    return [c for c in self.components if c.__class__.__name__ in [&#39;fan&#39;,
                                                                   &#39;prop&#39;,
                                                                   &#39;propfan&#39;,
                                                                   &#39;compressor&#39;]]</code></pre>
</details>
</dd>
<dt id="huracan.engine.shaft.w_r"><code class="name flex">
<span>def <span class="ident">w_r</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Obtain the work required by the components which
exert work on the gas (fan, compressors).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def w_r(self):
    &#34;&#34;&#34;
    Obtain the work required by the components which
    exert work on the gas (fan, compressors).
    &#34;&#34;&#34;
    wem = self.w_exerting_machinery()

    assert all([hasattr(c, &#39;w&#39;) for c in wem]), \
        &#34;The shaft&#39;s work exerting components do not have &#34; \
        &#34;a work attribute: ensure the streams to which each &#34; \
        &#34;belongs have been run up to the respective work &#34; \
        &#34;exerting component.&#34;

    work = np.array([c.w/self.eta_gearbox if c.__class__.__name__ in [&#39;fan&#39;, &#39;prop&#39;, &#39;propfan&#39;]
                     else c.w for c in wem])
    etas = np.array([c.shaft.eta for c in wem])
    w_r_m = np.sum(work/etas)                           # Power required by work exerting components

    electrical = self.electrical_plants()               # FIXME: ugly
    w_r_e = sum([c.w_r for c in electrical])            # Power required by all electrical plants

    return w_r_m + w_r_e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="huracan.engine.stream"><code class="flex name class">
<span>class <span class="ident">stream</span></span>
<span>(</span><span>gas=None, parents=None, fr=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="stream">Stream</h2>
<p>:param fr:
Fraction of the gas instance passed
to the stream which physically enters
the stream.
This is useful so the original gas
instance can be passed to child streams
in a stream diversion process.
In this way, the gas attribute of the
child streams points to the original
stream's gas instance until the moment
the child streams are run: at this
time, a deep copy of the original gas
instance is created, and the mass flow
multiplied by <em>fr</em> to reflect the mass
flow actually flowing in the child stream.
:param parents: Parent streams.
- If parents includes 2 or more streams,
they will be merged at runtime.</p>
<p>:type gas:
gas
:type fr:
float
:type parents: list of stream</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class stream(SET):
    &#34;&#34;&#34;
    Stream
    ------
    &#34;&#34;&#34;
    def __init__(self,
                 gas=None,
                 parents=None,
                 fr=None):
        &#34;&#34;&#34;
        :param fr:      Fraction of the gas instance passed
                        to the stream which physically enters
                        the stream.
                        This is useful so the original gas
                        instance can be passed to child streams
                        in a stream diversion process.
                        In this way, the gas attribute of the
                        child streams points to the original
                        stream&#39;s gas instance until the moment
                        the child streams are run: at this
                        time, a deep copy of the original gas
                        instance is created, and the mass flow
                        multiplied by _fr_ to reflect the mass
                        flow actually flowing in the child stream.
        :param parents: Parent streams.
                        - If parents includes 2 or more streams,
                          they will be merged at runtime.

        :type gas:     gas
        :type fr:      float
        :type parents: list of stream
        &#34;&#34;&#34;
        self.stream_id  = [0]
        self.components = []
        self.downstream = [self]

        self.ran = False

        if not isinstance(gas, type(None)):
            self.gas    = gas
        if not isinstance(parents, type(None)):
            self.parents = parents

        # Runtime dictionary
        self.runtime_d = {}
        if not isinstance(fr, type(None)):
            self.runtime_d[&#39;fr&#39;] = fr

    &#34;&#34;&#34;
    Operators
    &#34;&#34;&#34;
    def __call__(self, gas):
        self.gas = gas
        return self

    def __mul__(self, other):                       # TODO: stream diversion
        &#34;&#34;&#34;
        Stream diversion operator: &lt;stream&gt; * n     for n: 0 =&lt; float =&lt; 1
        &#34;&#34;&#34;
        return self.divert(other)

    def __getitem__(self, item):
        &#34;&#34;&#34;
        Component retrieval operator: &lt;stream&gt;[&lt;component stage name&gt;]
        &#34;&#34;&#34;
        return self.retrieve(item)

    &#34;&#34;&#34;
    Operator functions
    &#34;&#34;&#34;
    def add_component(self, c):
        &#34;&#34;&#34;
        Component addition
        &#34;&#34;&#34;
        self.components.append(c)
        c.downstream = self.downstream
        c.stream = c.set = self

    def add_set(self, s):
        &#34;&#34;&#34;
        Stream addition
        &#34;&#34;&#34;
        assert hasattr(self, &#39;gas&#39;) and hasattr(s, &#39;gas&#39;), &#39;Both streams must have a gas attribute for&#39; \
                                                           &#39;the stream merge operation to be possible.&#39;

        n = max(self.stream_id[0], s.stream_id[0])  # Get largest stream_id
        self.stream_id[0] = s.stream_id[0] = n      # Set largest stream_id for both merging streams

        merged = stream(parents=[self, s])
        merged.stream_id[0] = n + 1

        if hasattr(self, &#39;system&#39;) and hasattr(s, &#39;system&#39;):
            self.superset = self.system = s.system = merged.system = self.system + s.system
            self.system(merged)
        elif hasattr(self, &#39;system&#39;):
            self.system(s, merged)
        elif hasattr(s, &#39;system&#39;):
            s.system(self, merged)
        else:
            system(self, s, merged)

        return merged

    def divert(self, fr, names=None):
        &#34;&#34;&#34;
        Stream diversion
        &#34;&#34;&#34;

        assert hasattr(self, &#39;gas&#39;), &#39;The stream must have a gas attribute for&#39; \
                                     &#39;the stream diversion operation to be possible.&#39;

        main = stream(self.gas, fr=fr, parents=[self])
        div  = stream(self.gas, fr=1-fr, parents=[self])

        # Stream ID
        main.stream_id[0] = self.stream_id[0] + 1
        div.stream_id[0]  = self.stream_id[0] + 1

        # Diverted stream IDs
        if not isinstance(names, type(None)):
            main.stream_id.append(names[0])
            div.stream_id.append(names[1])
        else:
            mf_matrix = np.array([[main.gas.mf * fr,     main],
                                  [div.gas.mf  * (1-fr), div]])
            mf_matrix = mf_matrix[mf_matrix[:, 0].argsort()]

            for i in range(mf_matrix[:, 1].size):
                sub_id = &#39;m&#39; if i == 0 else f&#39;s{i}&#39; if i &gt; 1 else &#39;s&#39;
                mf_matrix[i, 1].stream_id.append(sub_id)

        if hasattr(self, &#39;system&#39;):
            self.system(main, div)
            main.system = div.system = self.system
        else:
            system(self, main, div)

        return main, div

    def retrieve(self, item):
        &#34;&#34;&#34;
        Retrieve any stream component by its stage name.

        :type item: str
        &#34;&#34;&#34;
        assert item in self.stages(), &#39;Specified a non-existent stage.&#39;

        for c in self.components:
            if c.stage == item:
                return c

    &#34;&#34;&#34;
    Utilities
    &#34;&#34;&#34;
    def stages(self):
        &#34;&#34;&#34;
        Return a list containing the stage name of each
        component in the stream.
        &#34;&#34;&#34;
        return [c.stage for c in self.components]

    def stage_name(self, c):
        &#34;&#34;&#34;
        Return the stage name of a component in the stream,
        composed of the stream identification number, a code
        representing its parent class, and a numerical index
        if there are more than 1 components of the same class
        in the stream.
        &#34;&#34;&#34;
        codes = {&#39;fan&#39;:                &#39;fn&#39;,
                 &#39;prop&#39;:               &#39;pr&#39;,
                 &#39;propfan&#39;:            &#39;pf&#39;,
                 &#39;intake&#39;:             &#39;it&#39;,
                 &#39;inlet&#39;:              &#39;il&#39;,
                 &#39;compressor&#39;:         &#39;cp&#39;,
                 &#39;combustion_chamber&#39;: &#39;cc&#39;,
                 &#39;turbine&#39;:            &#39;tb&#39;,
                 &#39;nozzle&#39;:             &#39;nz&#39;,

                 &#39;intercooler&#39;:        &#39;ic&#39;,
                 &#39;recuperator&#39;:        &#39;rc&#39;,
                 &#39;afterburner&#39;:        &#39;ab&#39;,
                 }

        code = codes[c.__class__.__name__] + self.n_instances(c)

        return f&#39;{&#34;.&#34;.join([str(c) for c in self.stream_id])}.{code}&#39;

    def n_instances(self, comp):
        &#34;&#34;&#34;
        Calculate the number of instances of a given component&#39;s
        parent class in the stream (n), and its index in the
        stream&#39;s components list (i).

        The index of the component is returned as follows:
        - If the given component is the only instance of its parent
          class in the stream (n = 1):
            - &#39;&#39;                                     (empty string)
        - If the given component is one of more instances of its
          parent class in the stream (n &gt; 1):
            - str(i + 1)                    (numeral starting at 1)

        :type comp: component
        &#34;&#34;&#34;

        i = 0       # Component index
        n = 0       # Number of instances of the input component&#39;s class in the stream
        for c in self.components:
            if comp is c:
                i = n
            if comp.__class__.__name__ == c.__class__.__name__:
                n += 1

        return &#39;&#39; if n == 1 else str(i + 1)

    def log(self):

        d = 9

        for c in self.components:
            section_name = join_set_distance(c.stage, c.__class__.__name__.capitalize().replace(&#34;_&#34;, &#34; &#34;), d)
            print_color(section_name, &#39;green&#39;)

            if c.__class__.__name__ == &#39;nozzle&#39;:
                if c.choked:
                    print_color(&#39; &#39;*d + &#39;Choked flow&#39;, &#39;red&#39;)
            print_result(&#39; &#39;*(d+1) + &#39;T0&#39;, c.t0, &#39;[K]&#39;)
            print_result(&#39; &#39;*(d+1) + &#39;p0&#39;, c.p0, &#39;[Pa]&#39;)

    &#34;&#34;&#34;
    Stream runtime functions
    &#34;&#34;&#34;
    def run(self, log=True):
        &#34;&#34;&#34;
        Execute the transfer functions of all components in the stream
        on the instance&#39;s gas class instance.
        &#34;&#34;&#34;

        self.runtime()

        assert hasattr(self, &#39;gas&#39;), &#39;stream does not have a gas attribute.&#39;

        self.choked = False                                 # FIXME: choked flow implementation is ugly

        for c in self.components:
            c(self.gas)                     # Run thermodynamic process on stream gas
            c.stage = self.stage_name(c)   # Set component stage name

            if hasattr(c, &#39;choked&#39;) and c.choked:           # FIXME: ugly
                self.choked = c.choked

        # Indicate stream has been run.
        self.ran = True

        if log:
            self.log()

    def runtime(self):
        if hasattr(self, &#39;parents&#39;) and len(self.parents) &gt; 1:
            self.merge()

        for k, v in self.runtime_d.items():
            f = getattr(self, k)
            f(v)

    def merge(self):
        if hasattr(self, &#39;gas&#39;):
            for s in self.parents:
                self.gas += s.gas
        else:
            self.gas = self.parents[0].gas
            for s in self.parents[1:]:
                self.gas += s.gas

    def fr(self, fr):
        self.gas, _ = fr * deepcopy(self.gas)

    &#34;&#34;&#34;
    Stream fluid state
    &#34;&#34;&#34;
    def t0(self):
        &#34;&#34;&#34;
        Total temperature vector.
        &#34;&#34;&#34;
        assert self.ran, &#39;The stream must be run to obtain the total temperature at each stage&#39;

        return np.array([c.t0 for c in self.components])

    def p0(self):
        &#34;&#34;&#34;
        Total pressure vector.
        &#34;&#34;&#34;
        assert self.ran, &#39;The stream must be run to obtain the total pressure at each stage&#39;

        return np.array([c.p0 for c in self.components])

    def V(self):
        &#34;&#34;&#34;
        Specific volume vector.
        &#34;&#34;&#34;
        assert self.ran, &#39;The stream must be run to obtain the specific volume at each stage&#39;

        return np.array([c.V for c in self.components])

    def S(self):
        &#34;&#34;&#34;
        Specific entropy vector.
        &#34;&#34;&#34;
        assert self.ran, &#39;The stream must be run to obtain the specific entropy at each stage&#39;

        return np.array([c.S for c in self.components])

    def H(self):
        &#34;&#34;&#34;
        Specific enthalpy vector.
        &#34;&#34;&#34;
        assert self.ran, &#39;The stream must be run to obtain the specific entropy at each stage&#39;

        return np.array([c.H for c in self.components])

    &#34;&#34;&#34;
    Stream outlet flow characteristics
    &#34;&#34;&#34;
    def v_exit(self):
        &#34;&#34;&#34;
        Flow exit velocity

        Assumptions:
        - If the flow is not choked:
             The thermal energy lost by the gas as it leaves the nozzle
             is transformed into kinetic energy without losses.
        - If the flow is choked:
             The exit velocity is the velocity of sound before the nozzle
             exit.
        &#34;&#34;&#34;
        # Absolute temperature before the stream exit (likely but not necessarily a nozzle)
        if len(self.components) &gt; 1:
            # If the stream has more components than 1, the absolute temperature
            # after the component previous to the last one is taken.
            if self.components[-1].__class__.__name__ == &#39;nozzle&#39;:
                t_before_exit = self.components[-2].t0
            else:
                t_before_exit = self.components[-1].t0
        else:
            if hasattr(self, &#39;parents&#39;):
                # If the stream has a single component and a parent stream or streams
                if len(self.parents) &gt; 1:
                    # If the stream has more than a single parent stream, the gases
                    # of each parent are copied, merged and the absolute temperature
                    # of the resulting gas mixture is taken.
                    for i in range(len(self.parents)):
                        if i == 0:
                            g = deepcopy(self.parents[i].gas)
                        else:
                            g += deepcopy(self.parents[i].gas)
                    t_before_exit = g.t0
                else:
                    # If the stream has a single parent, the absolute temperature
                    # of the parent&#39;s gas is taken.
                    t_before_exit = self.parents[0].gas.t0
            else:
                # Is the stream has a single component and no parent streams,
                # it is assumed that the setup consists of a intake-nozzle
                # setup, and the absolute temperature of the moving gas is
                # taken.
                t_before_exit = deepcopy(self.gas).absolute().t01

        if self.choked:
            return (self.gas.k(t_before_exit)*R*t_before_exit)**0.5         # M=1 immediately before nozzle exit
        else:
            assert t_before_exit - self.gas.t0 &gt; 0, &#39;The total temperature of the flow is lower before &#39; \
                                                    &#39;the nozzle tha outside the engine: this happens due to the &#39; \
                                                    &#39;compressors not providing enough energy to the flow. You must &#39; \
                                                    &#39;either increase the pressure ratio of the compressors or &#39; \
                                                    &#39;decrease the power extracted from the flow to solve the &#39; \
                                                    &#39;inconsistency.&#39;
            return (2*self.gas.cp(t_before_exit)*(t_before_exit - self.gas.t0))**0.5    # Heat -&gt; Kinetic energy

    def A_exit(self):
        &#34;&#34;&#34;
        Nozzle exit area
        &#34;&#34;&#34;
        return self.gas.mf*R*self.gas.t0/(self.gas.p0*self.v_exit())

    &#34;&#34;&#34;
    Fuel consumption
    &#34;&#34;&#34;
    def fmf(self):
        &#34;&#34;&#34;
        Stream fuel mass flow
        &#34;&#34;&#34;
        fmf = 0
        for c in self.components:
            if hasattr(c, &#39;fuel&#39;) and hasattr(c.fuel, &#39;mf&#39;):
                fmf += c.fuel.mf
        return fmf

    &#34;&#34;&#34;
    Thrust and specific fuel consumption
    &#34;&#34;&#34;
    def thrust_flow(self):
        &#34;&#34;&#34;
        Flow thrust

        If the flow is choked, the expansion of the gas contributes to the thrust of the flow.
        &#34;&#34;&#34;
        if self.choked:
            return self.gas.mf * (self.v_exit() - self.gas.v_0) + self.A_exit() * (
                        self.gas.p0 - self.gas.p_0)
        else:
            return self.gas.mf * (self.v_exit() - self.gas.v_0)

    def thrust_prop(self):
        &#34;&#34;&#34;
        Propeller/propfan thrust
        &#34;&#34;&#34;
        if any([c.__class__.__name__ in [&#39;prop&#39;, &#39;propfan&#39;] for c in self.components]):
            propellers = [c for c in self.components if c.__class__.__name__ in [&#39;prop&#39;, &#39;propfan&#39;]]
            thrust_prop = sum([prop.thrust(self.gas.v_0) for prop in propellers])
        else:
            thrust_prop = 0
        return thrust_prop

    def thrust_total(self):
        &#34;&#34;&#34;
        Flow thrust plus propeller/propfan thrust
        &#34;&#34;&#34;
        return self.thrust_flow() + self.thrust_prop()

    def sfc(self):
        &#34;&#34;&#34;
        Specific fuel consumption
        &#34;&#34;&#34;
        if hasattr(self, &#39;system&#39;):
            return self._fmf()/self._thrust_flow()
        else:
            return self.fmf()/self.thrust_flow()

    &#34;&#34;&#34;
    Heat and work
    &#34;&#34;&#34;
    def Q_in(self):                #TODO: verify efficiency calculations
        &#34;&#34;&#34;
        Heat provided to the flow.
        &#34;&#34;&#34;
        q_provided = 0
        for c in self.components:
            if c.__class__.__name__ == &#39;combustion_chamber&#39;:
                q_provided += c.Q
        return q_provided

    def W_req(self):
        &#34;&#34;&#34;
        Work required from the flow.
        &#34;&#34;&#34;
        w_required = 0
        for c in self.components:
            if c.__class__.__name__ in [&#39;fan&#39;,
                                        &#39;prop&#39;,
                                        &#39;propfan&#39;,
                                        &#39;compressor&#39;]:
                w_required += c.w
        return w_required

    &#34;&#34;&#34;
    Power
    &#34;&#34;&#34;
    def power_jet(self):
        &#34;&#34;&#34;
        Stream jet power.
        &#34;&#34;&#34;
        return 1/2*(self.gas.mf*self.v_exit()**2 - (self.gas.mf - self.fmf())*self.gas.v_0**2)

    def power_available(self):
        &#34;&#34;&#34;
        Stream available power.
        &#34;&#34;&#34;
        if hasattr(self, &#39;system&#39;):
            return self._efficiency_prop()*self._power_jet()
        else:
            return self.efficiency_prop()*self.power_jet()

    &#34;&#34;&#34;
    Efficiencies
    &#34;&#34;&#34;
    def efficiency_thermal(self):
        &#34;&#34;&#34;
        Stream thermal efficiency
        &#34;&#34;&#34;
        if hasattr(self, &#39;system&#39;):
            return self._power_jet()/self._Q_in()
        else:
            return self.power_jet()/self.Q_in()

    def efficiency_prop(self):
        &#34;&#34;&#34;
        Stream propulsive efficiency.
        &#34;&#34;&#34;
        return 2/(1+self.v_exit()/self.gas.v_0) if self.gas.v_0 &gt; 0 else 0

    def efficiency_total(self):
        if hasattr(self, &#39;system&#39;):
            return self._power_available()/self._Q_in()
        else:
            return self.power_available()/self.Q_in()

    &#34;&#34;&#34;
    Plots
    &#34;&#34;&#34;
    def plot_T_S(self,
             show=False,
             plot_label=None,
             color=colorscheme_one()[0],
             **kwargs):
        &#34;&#34;&#34;
        Temperature-Entropy stream plot.
        &#34;&#34;&#34;

        figure((9, 5))

        defaults = {&#39;x_label&#39;: &#39;$\Delta$S [kJ/K/n]&#39;,
                    &#39;y_label&#39;: &#39;T$_0$ [K]&#39;,}

        further_custom = {**defaults, **kwargs}

        self.plot_cycle_graph(self.S()/1000, self.t0(),
                              color=color,
                              plot_label=plot_label,
                              show=show,
                              # Further customization
                              y_tick_ndecimals=2,
                              **further_custom)

    def plot_p_V(self,
                 show=False,
                 plot_label=None,
                 color=colorscheme_one()[0],
                 **kwargs):
        &#34;&#34;&#34;
        Pressure-Volume stream plot.
        &#34;&#34;&#34;

        figure((9, 5))

        defaults = {&#39;x_label&#39;: &#39;v$_0$ [m$^3$/n]&#39;,
                    &#39;y_label&#39;: &#39;p$_0$ [kPa]&#39;}

        further_custom = {**defaults, **kwargs}

        self.plot_cycle_graph(self.V(), self.p0()/1000,
                              color=color,
                              plot_label=plot_label,
                              show=show,
                              # Further customization
                              y_tick_ndecimals=2,
                              **further_custom)

    def plot_H_p(self,
                 show=False,
                 plot_label=None,
                 color=colorscheme_one()[0],
                 **kwargs):
        &#34;&#34;&#34;
        Pressure-Enthalpy stream plot.
        &#34;&#34;&#34;

        figure((9, 5))

        defaults = {&#39;x_label&#39;: &#39;p$_0$ [kPa]&#39;,
                    &#39;y_label&#39;: &#39;H$_0$ [kJ]&#39;,}

        further_custom = {**defaults, **kwargs}

        self.plot_cycle_graph(self.p0()/1000, self.H()/1000,
                              color=color,
                              plot_label=plot_label,
                              show=show,
                              # Further customization
                              y_tick_ndecimals=2,
                              **further_custom)

    def plot_T_p(self,
             show=False,
             plot_label=None,
             color=colorscheme_one()[0],
             **kwargs):
        &#34;&#34;&#34;
        Temperature-Pressure system plot.
        &#34;&#34;&#34;

        figure((9, 5))

        defaults = {&#39;x_label&#39;: &#39;p$_0$ [kPa]&#39;,
                    &#39;y_label&#39;: &#39;T$_0$ [K]&#39;}

        further_custom = {**defaults, **kwargs}

        self.plot_cycle_graph(self.p0()/1000, self.t0(),
                              color=color,
                              plot_label=plot_label,
                              show=show,
                              # Further customization
                              x_tick_ndecimals=2,
                              **further_custom)

    def plot_cycle_graph(self,
                         x, y,
                         plot_label,
                         x_label, y_label,
                         color=colorscheme_one()[0],
                         show=False,
                         **kwargs
                         ):
        &#34;&#34;&#34;
        General plot composed of an MPL Plotter line and scatter plot.

        The default arguments plus any valid MPL Plotter line plotting
        class arguments can be passed to this function.
        &#34;&#34;&#34;
        fig = kwargs.pop(&#39;fig&#39;, None)

        defaults = {
            # Specifics
            &#39;point_size&#39;: 30,
            # Markers
            &#39;marker&#39;: &#39;x&#39;,
            # Color
            &#39;color&#39;: delta(color, -0.3),
            # Arrangement
            &#39;zorder&#39;: 2,
            # Further customization
            &#39;aspect&#39;: 1/2,
            &#39;x_tick_number&#39;: 10,
            &#39;y_tick_number&#39;: 10,
            &#39;demo_pad_plot&#39;: True,
            &#39;y_label_pad&#39;: 5,
        }

        further_custom = {**defaults, **kwargs}

        # Connecting lines
        line(   x=x, y=y,
                # Figure
                fig=fig,
                # Specifics
                line_width=1,
                # Color
                color=color, alpha=0.65,
                # Arrangement
                zorder=1,
                )
        # Stages
        scatter(x=x, y=y,
                # Figure
                fig=fig,
                # Further customization
                plot_label=plot_label,
                x_label=x_label,
                y_label=y_label,
                show=show,
                **further_custom)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="huracan.engine.SET" href="#huracan.engine.SET">SET</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="huracan.engine.stream.A_exit"><code class="name flex">
<span>def <span class="ident">A_exit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Nozzle exit area</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def A_exit(self):
    &#34;&#34;&#34;
    Nozzle exit area
    &#34;&#34;&#34;
    return self.gas.mf*R*self.gas.t0/(self.gas.p0*self.v_exit())</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.H"><code class="name flex">
<span>def <span class="ident">H</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Specific enthalpy vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def H(self):
    &#34;&#34;&#34;
    Specific enthalpy vector.
    &#34;&#34;&#34;
    assert self.ran, &#39;The stream must be run to obtain the specific entropy at each stage&#39;

    return np.array([c.H for c in self.components])</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.Q_in"><code class="name flex">
<span>def <span class="ident">Q_in</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Heat provided to the flow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Q_in(self):                #TODO: verify efficiency calculations
    &#34;&#34;&#34;
    Heat provided to the flow.
    &#34;&#34;&#34;
    q_provided = 0
    for c in self.components:
        if c.__class__.__name__ == &#39;combustion_chamber&#39;:
            q_provided += c.Q
    return q_provided</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.S"><code class="name flex">
<span>def <span class="ident">S</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Specific entropy vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def S(self):
    &#34;&#34;&#34;
    Specific entropy vector.
    &#34;&#34;&#34;
    assert self.ran, &#39;The stream must be run to obtain the specific entropy at each stage&#39;

    return np.array([c.S for c in self.components])</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.V"><code class="name flex">
<span>def <span class="ident">V</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Specific volume vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def V(self):
    &#34;&#34;&#34;
    Specific volume vector.
    &#34;&#34;&#34;
    assert self.ran, &#39;The stream must be run to obtain the specific volume at each stage&#39;

    return np.array([c.V for c in self.components])</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.W_req"><code class="name flex">
<span>def <span class="ident">W_req</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Work required from the flow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def W_req(self):
    &#34;&#34;&#34;
    Work required from the flow.
    &#34;&#34;&#34;
    w_required = 0
    for c in self.components:
        if c.__class__.__name__ in [&#39;fan&#39;,
                                    &#39;prop&#39;,
                                    &#39;propfan&#39;,
                                    &#39;compressor&#39;]:
            w_required += c.w
    return w_required</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.add_component"><code class="name flex">
<span>def <span class="ident">add_component</span></span>(<span>self, c)</span>
</code></dt>
<dd>
<div class="desc"><p>Component addition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_component(self, c):
    &#34;&#34;&#34;
    Component addition
    &#34;&#34;&#34;
    self.components.append(c)
    c.downstream = self.downstream
    c.stream = c.set = self</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.add_set"><code class="name flex">
<span>def <span class="ident">add_set</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"><p>Stream addition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_set(self, s):
    &#34;&#34;&#34;
    Stream addition
    &#34;&#34;&#34;
    assert hasattr(self, &#39;gas&#39;) and hasattr(s, &#39;gas&#39;), &#39;Both streams must have a gas attribute for&#39; \
                                                       &#39;the stream merge operation to be possible.&#39;

    n = max(self.stream_id[0], s.stream_id[0])  # Get largest stream_id
    self.stream_id[0] = s.stream_id[0] = n      # Set largest stream_id for both merging streams

    merged = stream(parents=[self, s])
    merged.stream_id[0] = n + 1

    if hasattr(self, &#39;system&#39;) and hasattr(s, &#39;system&#39;):
        self.superset = self.system = s.system = merged.system = self.system + s.system
        self.system(merged)
    elif hasattr(self, &#39;system&#39;):
        self.system(s, merged)
    elif hasattr(s, &#39;system&#39;):
        s.system(self, merged)
    else:
        system(self, s, merged)

    return merged</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.divert"><code class="name flex">
<span>def <span class="ident">divert</span></span>(<span>self, fr, names=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Stream diversion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def divert(self, fr, names=None):
    &#34;&#34;&#34;
    Stream diversion
    &#34;&#34;&#34;

    assert hasattr(self, &#39;gas&#39;), &#39;The stream must have a gas attribute for&#39; \
                                 &#39;the stream diversion operation to be possible.&#39;

    main = stream(self.gas, fr=fr, parents=[self])
    div  = stream(self.gas, fr=1-fr, parents=[self])

    # Stream ID
    main.stream_id[0] = self.stream_id[0] + 1
    div.stream_id[0]  = self.stream_id[0] + 1

    # Diverted stream IDs
    if not isinstance(names, type(None)):
        main.stream_id.append(names[0])
        div.stream_id.append(names[1])
    else:
        mf_matrix = np.array([[main.gas.mf * fr,     main],
                              [div.gas.mf  * (1-fr), div]])
        mf_matrix = mf_matrix[mf_matrix[:, 0].argsort()]

        for i in range(mf_matrix[:, 1].size):
            sub_id = &#39;m&#39; if i == 0 else f&#39;s{i}&#39; if i &gt; 1 else &#39;s&#39;
            mf_matrix[i, 1].stream_id.append(sub_id)

    if hasattr(self, &#39;system&#39;):
        self.system(main, div)
        main.system = div.system = self.system
    else:
        system(self, main, div)

    return main, div</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.efficiency_prop"><code class="name flex">
<span>def <span class="ident">efficiency_prop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stream propulsive efficiency.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def efficiency_prop(self):
    &#34;&#34;&#34;
    Stream propulsive efficiency.
    &#34;&#34;&#34;
    return 2/(1+self.v_exit()/self.gas.v_0) if self.gas.v_0 &gt; 0 else 0</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.efficiency_thermal"><code class="name flex">
<span>def <span class="ident">efficiency_thermal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stream thermal efficiency</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def efficiency_thermal(self):
    &#34;&#34;&#34;
    Stream thermal efficiency
    &#34;&#34;&#34;
    if hasattr(self, &#39;system&#39;):
        return self._power_jet()/self._Q_in()
    else:
        return self.power_jet()/self.Q_in()</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.efficiency_total"><code class="name flex">
<span>def <span class="ident">efficiency_total</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def efficiency_total(self):
    if hasattr(self, &#39;system&#39;):
        return self._power_available()/self._Q_in()
    else:
        return self.power_available()/self.Q_in()</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.fmf"><code class="name flex">
<span>def <span class="ident">fmf</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stream fuel mass flow</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fmf(self):
    &#34;&#34;&#34;
    Stream fuel mass flow
    &#34;&#34;&#34;
    fmf = 0
    for c in self.components:
        if hasattr(c, &#39;fuel&#39;) and hasattr(c.fuel, &#39;mf&#39;):
            fmf += c.fuel.mf
    return fmf</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.fr"><code class="name flex">
<span>def <span class="ident">fr</span></span>(<span>self, fr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fr(self, fr):
    self.gas, _ = fr * deepcopy(self.gas)</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log(self):

    d = 9

    for c in self.components:
        section_name = join_set_distance(c.stage, c.__class__.__name__.capitalize().replace(&#34;_&#34;, &#34; &#34;), d)
        print_color(section_name, &#39;green&#39;)

        if c.__class__.__name__ == &#39;nozzle&#39;:
            if c.choked:
                print_color(&#39; &#39;*d + &#39;Choked flow&#39;, &#39;red&#39;)
        print_result(&#39; &#39;*(d+1) + &#39;T0&#39;, c.t0, &#39;[K]&#39;)
        print_result(&#39; &#39;*(d+1) + &#39;p0&#39;, c.p0, &#39;[Pa]&#39;)</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge(self):
    if hasattr(self, &#39;gas&#39;):
        for s in self.parents:
            self.gas += s.gas
    else:
        self.gas = self.parents[0].gas
        for s in self.parents[1:]:
            self.gas += s.gas</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.n_instances"><code class="name flex">
<span>def <span class="ident">n_instances</span></span>(<span>self, comp)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the number of instances of a given component's
parent class in the stream (n), and its index in the
stream's components list (i).</p>
<p>The index of the component is returned as follows:
- If the given component is the only instance of its parent
class in the stream (n = 1):
- ''
(empty string)
- If the given component is one of more instances of its
parent class in the stream (n &gt; 1):
- str(i + 1)
(numeral starting at 1)</p>
<p>:type comp: component</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def n_instances(self, comp):
    &#34;&#34;&#34;
    Calculate the number of instances of a given component&#39;s
    parent class in the stream (n), and its index in the
    stream&#39;s components list (i).

    The index of the component is returned as follows:
    - If the given component is the only instance of its parent
      class in the stream (n = 1):
        - &#39;&#39;                                     (empty string)
    - If the given component is one of more instances of its
      parent class in the stream (n &gt; 1):
        - str(i + 1)                    (numeral starting at 1)

    :type comp: component
    &#34;&#34;&#34;

    i = 0       # Component index
    n = 0       # Number of instances of the input component&#39;s class in the stream
    for c in self.components:
        if comp is c:
            i = n
        if comp.__class__.__name__ == c.__class__.__name__:
            n += 1

    return &#39;&#39; if n == 1 else str(i + 1)</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.p0"><code class="name flex">
<span>def <span class="ident">p0</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Total pressure vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def p0(self):
    &#34;&#34;&#34;
    Total pressure vector.
    &#34;&#34;&#34;
    assert self.ran, &#39;The stream must be run to obtain the total pressure at each stage&#39;

    return np.array([c.p0 for c in self.components])</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.plot_H_p"><code class="name flex">
<span>def <span class="ident">plot_H_p</span></span>(<span>self, show=False, plot_label=None, color='darkred', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Pressure-Enthalpy stream plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_H_p(self,
             show=False,
             plot_label=None,
             color=colorscheme_one()[0],
             **kwargs):
    &#34;&#34;&#34;
    Pressure-Enthalpy stream plot.
    &#34;&#34;&#34;

    figure((9, 5))

    defaults = {&#39;x_label&#39;: &#39;p$_0$ [kPa]&#39;,
                &#39;y_label&#39;: &#39;H$_0$ [kJ]&#39;,}

    further_custom = {**defaults, **kwargs}

    self.plot_cycle_graph(self.p0()/1000, self.H()/1000,
                          color=color,
                          plot_label=plot_label,
                          show=show,
                          # Further customization
                          y_tick_ndecimals=2,
                          **further_custom)</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.plot_T_S"><code class="name flex">
<span>def <span class="ident">plot_T_S</span></span>(<span>self, show=False, plot_label=None, color='darkred', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Temperature-Entropy stream plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_T_S(self,
         show=False,
         plot_label=None,
         color=colorscheme_one()[0],
         **kwargs):
    &#34;&#34;&#34;
    Temperature-Entropy stream plot.
    &#34;&#34;&#34;

    figure((9, 5))

    defaults = {&#39;x_label&#39;: &#39;$\Delta$S [kJ/K/n]&#39;,
                &#39;y_label&#39;: &#39;T$_0$ [K]&#39;,}

    further_custom = {**defaults, **kwargs}

    self.plot_cycle_graph(self.S()/1000, self.t0(),
                          color=color,
                          plot_label=plot_label,
                          show=show,
                          # Further customization
                          y_tick_ndecimals=2,
                          **further_custom)</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.plot_T_p"><code class="name flex">
<span>def <span class="ident">plot_T_p</span></span>(<span>self, show=False, plot_label=None, color='darkred', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Temperature-Pressure system plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_T_p(self,
         show=False,
         plot_label=None,
         color=colorscheme_one()[0],
         **kwargs):
    &#34;&#34;&#34;
    Temperature-Pressure system plot.
    &#34;&#34;&#34;

    figure((9, 5))

    defaults = {&#39;x_label&#39;: &#39;p$_0$ [kPa]&#39;,
                &#39;y_label&#39;: &#39;T$_0$ [K]&#39;}

    further_custom = {**defaults, **kwargs}

    self.plot_cycle_graph(self.p0()/1000, self.t0(),
                          color=color,
                          plot_label=plot_label,
                          show=show,
                          # Further customization
                          x_tick_ndecimals=2,
                          **further_custom)</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.plot_cycle_graph"><code class="name flex">
<span>def <span class="ident">plot_cycle_graph</span></span>(<span>self, x, y, plot_label, x_label, y_label, color='darkred', show=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>General plot composed of an MPL Plotter line and scatter plot.</p>
<p>The default arguments plus any valid MPL Plotter line plotting
class arguments can be passed to this function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_cycle_graph(self,
                     x, y,
                     plot_label,
                     x_label, y_label,
                     color=colorscheme_one()[0],
                     show=False,
                     **kwargs
                     ):
    &#34;&#34;&#34;
    General plot composed of an MPL Plotter line and scatter plot.

    The default arguments plus any valid MPL Plotter line plotting
    class arguments can be passed to this function.
    &#34;&#34;&#34;
    fig = kwargs.pop(&#39;fig&#39;, None)

    defaults = {
        # Specifics
        &#39;point_size&#39;: 30,
        # Markers
        &#39;marker&#39;: &#39;x&#39;,
        # Color
        &#39;color&#39;: delta(color, -0.3),
        # Arrangement
        &#39;zorder&#39;: 2,
        # Further customization
        &#39;aspect&#39;: 1/2,
        &#39;x_tick_number&#39;: 10,
        &#39;y_tick_number&#39;: 10,
        &#39;demo_pad_plot&#39;: True,
        &#39;y_label_pad&#39;: 5,
    }

    further_custom = {**defaults, **kwargs}

    # Connecting lines
    line(   x=x, y=y,
            # Figure
            fig=fig,
            # Specifics
            line_width=1,
            # Color
            color=color, alpha=0.65,
            # Arrangement
            zorder=1,
            )
    # Stages
    scatter(x=x, y=y,
            # Figure
            fig=fig,
            # Further customization
            plot_label=plot_label,
            x_label=x_label,
            y_label=y_label,
            show=show,
            **further_custom)</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.plot_p_V"><code class="name flex">
<span>def <span class="ident">plot_p_V</span></span>(<span>self, show=False, plot_label=None, color='darkred', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Pressure-Volume stream plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_p_V(self,
             show=False,
             plot_label=None,
             color=colorscheme_one()[0],
             **kwargs):
    &#34;&#34;&#34;
    Pressure-Volume stream plot.
    &#34;&#34;&#34;

    figure((9, 5))

    defaults = {&#39;x_label&#39;: &#39;v$_0$ [m$^3$/n]&#39;,
                &#39;y_label&#39;: &#39;p$_0$ [kPa]&#39;}

    further_custom = {**defaults, **kwargs}

    self.plot_cycle_graph(self.V(), self.p0()/1000,
                          color=color,
                          plot_label=plot_label,
                          show=show,
                          # Further customization
                          y_tick_ndecimals=2,
                          **further_custom)</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.power_available"><code class="name flex">
<span>def <span class="ident">power_available</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stream available power.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def power_available(self):
    &#34;&#34;&#34;
    Stream available power.
    &#34;&#34;&#34;
    if hasattr(self, &#39;system&#39;):
        return self._efficiency_prop()*self._power_jet()
    else:
        return self.efficiency_prop()*self.power_jet()</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.power_jet"><code class="name flex">
<span>def <span class="ident">power_jet</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stream jet power.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def power_jet(self):
    &#34;&#34;&#34;
    Stream jet power.
    &#34;&#34;&#34;
    return 1/2*(self.gas.mf*self.v_exit()**2 - (self.gas.mf - self.fmf())*self.gas.v_0**2)</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.retrieve"><code class="name flex">
<span>def <span class="ident">retrieve</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve any stream component by its stage name.</p>
<p>:type item: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve(self, item):
    &#34;&#34;&#34;
    Retrieve any stream component by its stage name.

    :type item: str
    &#34;&#34;&#34;
    assert item in self.stages(), &#39;Specified a non-existent stage.&#39;

    for c in self.components:
        if c.stage == item:
            return c</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, log=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute the transfer functions of all components in the stream
on the instance's gas class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, log=True):
    &#34;&#34;&#34;
    Execute the transfer functions of all components in the stream
    on the instance&#39;s gas class instance.
    &#34;&#34;&#34;

    self.runtime()

    assert hasattr(self, &#39;gas&#39;), &#39;stream does not have a gas attribute.&#39;

    self.choked = False                                 # FIXME: choked flow implementation is ugly

    for c in self.components:
        c(self.gas)                     # Run thermodynamic process on stream gas
        c.stage = self.stage_name(c)   # Set component stage name

        if hasattr(c, &#39;choked&#39;) and c.choked:           # FIXME: ugly
            self.choked = c.choked

    # Indicate stream has been run.
    self.ran = True

    if log:
        self.log()</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.runtime"><code class="name flex">
<span>def <span class="ident">runtime</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runtime(self):
    if hasattr(self, &#39;parents&#39;) and len(self.parents) &gt; 1:
        self.merge()

    for k, v in self.runtime_d.items():
        f = getattr(self, k)
        f(v)</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.sfc"><code class="name flex">
<span>def <span class="ident">sfc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Specific fuel consumption</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sfc(self):
    &#34;&#34;&#34;
    Specific fuel consumption
    &#34;&#34;&#34;
    if hasattr(self, &#39;system&#39;):
        return self._fmf()/self._thrust_flow()
    else:
        return self.fmf()/self.thrust_flow()</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.stage_name"><code class="name flex">
<span>def <span class="ident">stage_name</span></span>(<span>self, c)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the stage name of a component in the stream,
composed of the stream identification number, a code
representing its parent class, and a numerical index
if there are more than 1 components of the same class
in the stream.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stage_name(self, c):
    &#34;&#34;&#34;
    Return the stage name of a component in the stream,
    composed of the stream identification number, a code
    representing its parent class, and a numerical index
    if there are more than 1 components of the same class
    in the stream.
    &#34;&#34;&#34;
    codes = {&#39;fan&#39;:                &#39;fn&#39;,
             &#39;prop&#39;:               &#39;pr&#39;,
             &#39;propfan&#39;:            &#39;pf&#39;,
             &#39;intake&#39;:             &#39;it&#39;,
             &#39;inlet&#39;:              &#39;il&#39;,
             &#39;compressor&#39;:         &#39;cp&#39;,
             &#39;combustion_chamber&#39;: &#39;cc&#39;,
             &#39;turbine&#39;:            &#39;tb&#39;,
             &#39;nozzle&#39;:             &#39;nz&#39;,

             &#39;intercooler&#39;:        &#39;ic&#39;,
             &#39;recuperator&#39;:        &#39;rc&#39;,
             &#39;afterburner&#39;:        &#39;ab&#39;,
             }

    code = codes[c.__class__.__name__] + self.n_instances(c)

    return f&#39;{&#34;.&#34;.join([str(c) for c in self.stream_id])}.{code}&#39;</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.stages"><code class="name flex">
<span>def <span class="ident">stages</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list containing the stage name of each
component in the stream.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stages(self):
    &#34;&#34;&#34;
    Return a list containing the stage name of each
    component in the stream.
    &#34;&#34;&#34;
    return [c.stage for c in self.components]</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.t0"><code class="name flex">
<span>def <span class="ident">t0</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Total temperature vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def t0(self):
    &#34;&#34;&#34;
    Total temperature vector.
    &#34;&#34;&#34;
    assert self.ran, &#39;The stream must be run to obtain the total temperature at each stage&#39;

    return np.array([c.t0 for c in self.components])</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.thrust_flow"><code class="name flex">
<span>def <span class="ident">thrust_flow</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Flow thrust</p>
<p>If the flow is choked, the expansion of the gas contributes to the thrust of the flow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thrust_flow(self):
    &#34;&#34;&#34;
    Flow thrust

    If the flow is choked, the expansion of the gas contributes to the thrust of the flow.
    &#34;&#34;&#34;
    if self.choked:
        return self.gas.mf * (self.v_exit() - self.gas.v_0) + self.A_exit() * (
                    self.gas.p0 - self.gas.p_0)
    else:
        return self.gas.mf * (self.v_exit() - self.gas.v_0)</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.thrust_prop"><code class="name flex">
<span>def <span class="ident">thrust_prop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Propeller/propfan thrust</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thrust_prop(self):
    &#34;&#34;&#34;
    Propeller/propfan thrust
    &#34;&#34;&#34;
    if any([c.__class__.__name__ in [&#39;prop&#39;, &#39;propfan&#39;] for c in self.components]):
        propellers = [c for c in self.components if c.__class__.__name__ in [&#39;prop&#39;, &#39;propfan&#39;]]
        thrust_prop = sum([prop.thrust(self.gas.v_0) for prop in propellers])
    else:
        thrust_prop = 0
    return thrust_prop</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.thrust_total"><code class="name flex">
<span>def <span class="ident">thrust_total</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Flow thrust plus propeller/propfan thrust</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thrust_total(self):
    &#34;&#34;&#34;
    Flow thrust plus propeller/propfan thrust
    &#34;&#34;&#34;
    return self.thrust_flow() + self.thrust_prop()</code></pre>
</details>
</dd>
<dt id="huracan.engine.stream.v_exit"><code class="name flex">
<span>def <span class="ident">v_exit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Flow exit velocity</p>
<p>Assumptions:
- If the flow is not choked:
The thermal energy lost by the gas as it leaves the nozzle
is transformed into kinetic energy without losses.
- If the flow is choked:
The exit velocity is the velocity of sound before the nozzle
exit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def v_exit(self):
    &#34;&#34;&#34;
    Flow exit velocity

    Assumptions:
    - If the flow is not choked:
         The thermal energy lost by the gas as it leaves the nozzle
         is transformed into kinetic energy without losses.
    - If the flow is choked:
         The exit velocity is the velocity of sound before the nozzle
         exit.
    &#34;&#34;&#34;
    # Absolute temperature before the stream exit (likely but not necessarily a nozzle)
    if len(self.components) &gt; 1:
        # If the stream has more components than 1, the absolute temperature
        # after the component previous to the last one is taken.
        if self.components[-1].__class__.__name__ == &#39;nozzle&#39;:
            t_before_exit = self.components[-2].t0
        else:
            t_before_exit = self.components[-1].t0
    else:
        if hasattr(self, &#39;parents&#39;):
            # If the stream has a single component and a parent stream or streams
            if len(self.parents) &gt; 1:
                # If the stream has more than a single parent stream, the gases
                # of each parent are copied, merged and the absolute temperature
                # of the resulting gas mixture is taken.
                for i in range(len(self.parents)):
                    if i == 0:
                        g = deepcopy(self.parents[i].gas)
                    else:
                        g += deepcopy(self.parents[i].gas)
                t_before_exit = g.t0
            else:
                # If the stream has a single parent, the absolute temperature
                # of the parent&#39;s gas is taken.
                t_before_exit = self.parents[0].gas.t0
        else:
            # Is the stream has a single component and no parent streams,
            # it is assumed that the setup consists of a intake-nozzle
            # setup, and the absolute temperature of the moving gas is
            # taken.
            t_before_exit = deepcopy(self.gas).absolute().t01

    if self.choked:
        return (self.gas.k(t_before_exit)*R*t_before_exit)**0.5         # M=1 immediately before nozzle exit
    else:
        assert t_before_exit - self.gas.t0 &gt; 0, &#39;The total temperature of the flow is lower before &#39; \
                                                &#39;the nozzle tha outside the engine: this happens due to the &#39; \
                                                &#39;compressors not providing enough energy to the flow. You must &#39; \
                                                &#39;either increase the pressure ratio of the compressors or &#39; \
                                                &#39;decrease the power extracted from the flow to solve the &#39; \
                                                &#39;inconsistency.&#39;
        return (2*self.gas.cp(t_before_exit)*(t_before_exit - self.gas.t0))**0.5    # Heat -&gt; Kinetic energy</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="huracan.engine.SET" href="#huracan.engine.SET">SET</a></b></code>:
<ul class="hlist">
<li><code><a title="huracan.engine.SET.superset_takeover" href="#huracan.engine.SET.superset_takeover">superset_takeover</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="huracan.engine.system"><code class="flex name class">
<span>class <span class="ident">system</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="system">System</h2>
<p>Create a system from two objects.</p>
<p>:type args: stream</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class system(SUPERSET):
    &#34;&#34;&#34;
    System
    ------
    &#34;&#34;&#34;
    def __init__(self, *args):
        &#34;&#34;&#34;
        Create a system from two objects.

        :type args: stream
        &#34;&#34;&#34;
        self.streams = []
        self.gobble(list(args))

    &#34;&#34;&#34;
    Operators
    &#34;&#34;&#34;
    def __add__(self, other):
        &#34;&#34;&#34;
        System addition operator: &lt;system&gt; + &lt;stream/system&gt;

        :type other: system
        &#34;&#34;&#34;
        streams = list(set(self.streams) &amp; set(other.streams))
        return system(*streams)

    def __getitem__(self, item):
        &#34;&#34;&#34;
        Component retrieval operator: &lt;system&gt;[&lt;component stage name&gt;]
        &#34;&#34;&#34;
        return self.retrieve(item)

    &#34;&#34;&#34;
    Operator functions
    &#34;&#34;&#34;
    def gobble(self, streams):
        &#34;&#34;&#34;
        :type streams: list of stream
        &#34;&#34;&#34;
        for s in streams:
            self.streams.append(s)
            s.superset = s.system = self
            s.superset_takeover()

    def retrieve(self, item):
        &#34;&#34;&#34;
        Retrieve any stream component by its stage name.

        :type item: str
        &#34;&#34;&#34;
        components = []
        for s in self.streams:
            components += s.components

        assert item in [c.stage for c in components], &#39;Specified a non-existent stage.&#39;

        for c in components:
            if c.stage == item:
                return c

    &#34;&#34;&#34;
    System functions
    &#34;&#34;&#34;
    def run(self, log=True):
        &#34;&#34;&#34;
        Run stream system.
        &#34;&#34;&#34;

        self.sort_streams()

        n = 0
        while not all([s.ran for s in self.streams]):
            for s in self.streams:
                if s.stream_id[0] == n:
                    s._run(log)
            n += 1

    def sort_streams(self):
        &#34;&#34;&#34;
        Sort system streams based on their stream ID
        &#34;&#34;&#34;
        ids     = [&#39;&#39;.join(str(c) for c in stream.stream_id) for stream in self.streams]
        indexes = [float(id.replace(&#39;m&#39;, &#39;.1&#39;).replace(&#39;s&#39;, &#39;.2&#39;)) for id in ids]
        self.streams = [s for _, s in sorted(zip(indexes, self.streams))]

    def parents(self):
        &#34;&#34;&#34;
        Return all system streams with children.
        Useful to not calculate thrust, exit velocity
        and other stream outlet values for streams
        flowing to children streams.
        &#34;&#34;&#34;
        parents = []
        for s in self.streams:
            parents += s.parents if hasattr(s, &#39;parents&#39;) else []
        return parents

    &#34;&#34;&#34;
    Fuel consumption
    &#34;&#34;&#34;
    def fmf(self):
        &#34;&#34;&#34;
        System fuel mass flow.
        &#34;&#34;&#34;
        return sum([s._fmf() for s in self.streams])

    &#34;&#34;&#34;
    Thrust and specific fuel consumption
    &#34;&#34;&#34;
    def thrust_flow(self):
        &#34;&#34;&#34;
        System flow thrust.
        &#34;&#34;&#34;
        return sum([s._thrust_flow() for s in self.streams if s not in self.parents()])

    def thrust_prop(self):
        &#34;&#34;&#34;
        System propeller thrust
        &#34;&#34;&#34;
        return sum([s._thrust_prop() for s in self.streams])

    def thrust_total(self):
        &#34;&#34;&#34;
        System total thrust.
        &#34;&#34;&#34;
        return self.thrust_flow() + self.thrust_prop()

    def sfc(self):
        &#34;&#34;&#34;
        System specific fuel consumption.
        &#34;&#34;&#34;
        return self.fmf()/self.thrust_flow()

    &#34;&#34;&#34;
    Heat and work
    &#34;&#34;&#34;
    def Q_in(self):                 # TODO: verify efficiency calculations
        &#34;&#34;&#34;
        Heat provided to the flow.
        &#34;&#34;&#34;
        return sum([s._Q_in() for s in self.streams])

    def W_req(self):
        &#34;&#34;&#34;
        Work required from the flow.
        &#34;&#34;&#34;
        return sum([s._W_req() for s in self.streams])

    &#34;&#34;&#34;
    Power
    &#34;&#34;&#34;
    def power_jet(self):
        &#34;&#34;&#34;
        Stream jet power.
        &#34;&#34;&#34;
        return sum([s._power_jet() for s in self.streams if s not in self.parents()])

    def power_available(self):
        &#34;&#34;&#34;
        Stream available power.
        &#34;&#34;&#34;
        return sum([s._power_available() for s in self.streams if s not in self.parents()])

    &#34;&#34;&#34;
    Efficiencies
    &#34;&#34;&#34;
    def efficiency_prop(self):
        &#34;&#34;&#34;
        System propulsive efficiency.
        &#34;&#34;&#34;
        return self.power_available()/self.power_jet()

    def efficiency_thermal(self):
        &#34;&#34;&#34;
        System thermal efficiency.
        &#34;&#34;&#34;
        return self.power_jet()/self.Q_in()

    def efficiency_total(self):
        &#34;&#34;&#34;
        System total efficiency.
        &#34;&#34;&#34;
        return self.power_available()/self.Q_in()

    &#34;&#34;&#34;
    Plots
    &#34;&#34;&#34;
    def plot(self,
             x, y,
             x_scale=None, y_scale=None,
             x_label=None, y_label=None,
             show=False,
             plot_label=None,                  # When called from a _system_takeover the plot_label and color
             color=colorscheme_one()[0],       # arguments are passed to the function, but disregarded.
             colorblind=False,
             **kwargs):
        &#34;&#34;&#34;
        System plot
        -----------

        x and y are the stream parameters to be
        plotted for each stream.

        Process
        1. Create figure
        2. Create state variable and plotters vectors
            2.1 Parent connectors
        3. comparison call

        comparison call
            - fig=None, ax=None -&gt; plot_cycle_graph -&gt; fig in **kwargs keys
                - fig=None, ax=None -&gt; line, scatter
                    - line, scatter plot onto active figure, axis

        :param x_scale: Scaling factor.
        :param y_scale: Scaling factor.

        :type x:        str
        :type y:        str
        :type x_scale:  float
        :type y_scale:  float
        &#34;&#34;&#34;
        plotters   = []
        x_system   = []
        y_system   = []

        defaults   = {&#39;legend&#39;: kwargs.pop(&#39;legend&#39;, True)}

        scales     = {&#39;t0&#39;: 1,
                      &#39;p0&#39;: 1/1000,
                      &#39;V&#39;:  1,
                      &#39;S&#39;:  1/1000,
                      &#39;H&#39;:  1/1000}
        x_scale    = scales[x] if isinstance(x_scale, type(None)) else x_scale
        y_scale    = scales[y] if isinstance(y_scale, type(None)) else y_scale

        # 1. Create figure
        figure((9, 5))

        # 2. Create state variable and plotters vectors
        for stream in self.streams:

            # Plot defaults
            subplot_defaults = {
                &#39;plot_label&#39;: f&#39;{&#34;.&#34;.join([str(c) for c in stream.stream_id])}&#39;,
                &#39;x_label&#39;: x_label,
                &#39;y_label&#39;: y_label,
                &#39;color&#39;: colorscheme_one()[self.streams.index(stream)],
                &#39;zorder&#39;: self.streams.index(stream),
            }

            if colorblind:
                m      = markers(hollow=True)
                marker = m[self.streams.index(stream)]
                subplot_defaults = {**subplot_defaults, **marker}

            def gen_plotter(**defaults):
                &#34;&#34;&#34;
                Returns a plotter using the defaults.
                Any keyword arguemnts passed to the
                _plot function overwrite the defaults.
                &#34;&#34;&#34;
                return lambda x, y, **kwargs: stream.plot_cycle_graph(x=x, y=y, **{**defaults, **kwargs})

            x_stream = getattr(stream, x)()*x_scale
            y_stream = getattr(stream, y)()*y_scale

            plotters.append(gen_plotter(**subplot_defaults))
            x_system.append(x_stream)
            y_system.append(y_stream)

            # 2.1 Parent connectors
            if hasattr(stream, &#39;parents&#39;):
                for parent in stream.parents:
                    x_parent = getattr(parent, x)()*x_scale
                    y_parent = getattr(parent, y)()*y_scale
                    # If the parent stream has no stages, get parent stream&#39;s gas state
                    p_x = x_parent[-1] if len(x_parent) != 0 else getattr(parent.gas, x)*x_scale
                    p_y = y_parent[-1] if len(y_parent) != 0 else getattr(parent.gas, y)*y_scale
                    # Connector
                    if len(stream.components) &gt; 0:
                        x_system.append(np.array([p_x, x_stream[0]]))
                        y_system.append(np.array([p_y, y_stream[0]]))

                        connector_args = {&#39;color&#39;: subplot_defaults[&#39;color&#39;],
                                          &#39;zorder&#39;: self.streams.index(stream),
                                          &#39;plot_label&#39;: None,
                                          &#39;x_label&#39;: None,
                                          &#39;y_label&#39;: None,
                                          &#39;marker&#39;: &#39;&#39;
                                          }

                        if colorblind:
                            connector_args = {**connector_args}

                        plotters.append(gen_plotter(**connector_args))

        # 2.2 Remove streams with no stages
        mask_x = np.array([a.size != 0 for a in x_system])
        mask_y = np.array([a.size != 0 for a in y_system])
        mask = mask_x * mask_y  # Ensure that any x-y array pairs with an empty array are removed

        x_system = np.array(x_system, dtype=&#39;object&#39;)[mask].tolist()
        y_system = np.array(y_system, dtype=&#39;object&#39;)[mask].tolist()
        plotters = np.array(plotters, dtype=&#39;object&#39;)[mask].tolist()

        # 4. comparison call
        #     - fig=None, ax=None -&gt; plot_cycle_graph -&gt; fig in **kwargs keys
        #         - fig=None, ax=None -&gt; line, scatter
        #             - line, scatter plot onto active figure, axis
        comparison(x=x_system,
                   y=y_system,
                   f=plotters,
                   legend_loc=(0.865, 0.425),
                   autocolor=False,
                   show=show,
                   **{**kwargs, **defaults})

    def plot_T_p(self,
                 show=False,
                 plot_label=None,
                 color=colorscheme_one()[0],
                 colorblind=False,
                 **kwargs
                 ):
        &#34;&#34;&#34;
        Temperature-Pressure system plot.
        &#34;&#34;&#34;
        args = locals()
        args.pop(&#39;self&#39;, None)
        args.pop(&#39;kwargs&#39;, None)

        self.plot(x=&#39;p0&#39;, x_label=&#39;p$_0$ [kPa]&#39;,
                  y=&#39;t0&#39;, y_label=&#39;T$_0$ [K]&#39;,
                  **{**args, **kwargs})

    def plot_p_V(self,
                 show=False,
                 plot_label=None,
                 color=colorscheme_one()[0],
                 colorblind=False,
                 **kwargs):
        &#34;&#34;&#34;
        Pressure-Volume system plot.
        &#34;&#34;&#34;
        args = locals()
        args.pop(&#39;self&#39;, None)
        args.pop(&#39;kwargs&#39;, None)

        self.plot(x=&#39;V&#39;,  x_label=&#39;v$_0$ [m$^3$/n]&#39;,
                  y=&#39;p0&#39;, y_label=&#39;p$_0$ [kPa]&#39;,
                  **{**args, **kwargs})

    def plot_T_S(self,
                 show=False,
                 plot_label=None,
                 color=colorscheme_one()[0],
                 colorblind=False,
                 **kwargs):
        &#34;&#34;&#34;
        Temperature-Entropy system plot.
        &#34;&#34;&#34;
        args = locals()
        args.pop(&#39;self&#39;, None)
        args.pop(&#39;kwargs&#39;, None)

        self.plot(x=&#39;S&#39;,  x_label=&#39;$\Delta$S [kJ/K]&#39;,
                  y=&#39;t0&#39;, y_label=&#39;T$_0$ [K]&#39;,
                  **{**args, **kwargs})

    def plot_H_p(self,
                 show=False,
                 plot_label=None,
                 color=colorscheme_one()[0],
                 colorblind=False,
                 **kwargs):
        &#34;&#34;&#34;
        Pressure-Enthalpy system plot.
        &#34;&#34;&#34;
        args = locals()
        args.pop(&#39;self&#39;, None)
        args.pop(&#39;kwargs&#39;, None)

        self.plot(x=&#39;p0&#39;, x_label=&#39;p$_0$ [kPa]&#39;,
                  y=&#39;H&#39;,  y_label=&#39;H$_0$ [kJ]&#39;,
                  **{**args, **kwargs})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="huracan.engine.SUPERSET" href="#huracan.engine.SUPERSET">SUPERSET</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="huracan.engine.system.Q_in"><code class="name flex">
<span>def <span class="ident">Q_in</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Heat provided to the flow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Q_in(self):                 # TODO: verify efficiency calculations
    &#34;&#34;&#34;
    Heat provided to the flow.
    &#34;&#34;&#34;
    return sum([s._Q_in() for s in self.streams])</code></pre>
</details>
</dd>
<dt id="huracan.engine.system.W_req"><code class="name flex">
<span>def <span class="ident">W_req</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Work required from the flow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def W_req(self):
    &#34;&#34;&#34;
    Work required from the flow.
    &#34;&#34;&#34;
    return sum([s._W_req() for s in self.streams])</code></pre>
</details>
</dd>
<dt id="huracan.engine.system.efficiency_prop"><code class="name flex">
<span>def <span class="ident">efficiency_prop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>System propulsive efficiency.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def efficiency_prop(self):
    &#34;&#34;&#34;
    System propulsive efficiency.
    &#34;&#34;&#34;
    return self.power_available()/self.power_jet()</code></pre>
</details>
</dd>
<dt id="huracan.engine.system.efficiency_thermal"><code class="name flex">
<span>def <span class="ident">efficiency_thermal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>System thermal efficiency.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def efficiency_thermal(self):
    &#34;&#34;&#34;
    System thermal efficiency.
    &#34;&#34;&#34;
    return self.power_jet()/self.Q_in()</code></pre>
</details>
</dd>
<dt id="huracan.engine.system.efficiency_total"><code class="name flex">
<span>def <span class="ident">efficiency_total</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>System total efficiency.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def efficiency_total(self):
    &#34;&#34;&#34;
    System total efficiency.
    &#34;&#34;&#34;
    return self.power_available()/self.Q_in()</code></pre>
</details>
</dd>
<dt id="huracan.engine.system.fmf"><code class="name flex">
<span>def <span class="ident">fmf</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>System fuel mass flow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fmf(self):
    &#34;&#34;&#34;
    System fuel mass flow.
    &#34;&#34;&#34;
    return sum([s._fmf() for s in self.streams])</code></pre>
</details>
</dd>
<dt id="huracan.engine.system.gobble"><code class="name flex">
<span>def <span class="ident">gobble</span></span>(<span>self, streams)</span>
</code></dt>
<dd>
<div class="desc"><p>:type streams: list of stream</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gobble(self, streams):
    &#34;&#34;&#34;
    :type streams: list of stream
    &#34;&#34;&#34;
    for s in streams:
        self.streams.append(s)
        s.superset = s.system = self
        s.superset_takeover()</code></pre>
</details>
</dd>
<dt id="huracan.engine.system.parents"><code class="name flex">
<span>def <span class="ident">parents</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all system streams with children.
Useful to not calculate thrust, exit velocity
and other stream outlet values for streams
flowing to children streams.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parents(self):
    &#34;&#34;&#34;
    Return all system streams with children.
    Useful to not calculate thrust, exit velocity
    and other stream outlet values for streams
    flowing to children streams.
    &#34;&#34;&#34;
    parents = []
    for s in self.streams:
        parents += s.parents if hasattr(s, &#39;parents&#39;) else []
    return parents</code></pre>
</details>
</dd>
<dt id="huracan.engine.system.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, x, y, x_scale=None, y_scale=None, x_label=None, y_label=None, show=False, plot_label=None, color='darkred', colorblind=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="system-plot">System Plot</h2>
<p>x and y are the stream parameters to be
plotted for each stream.</p>
<p>Process
1. Create figure
2. Create state variable and plotters vectors
2.1 Parent connectors
3. comparison call</p>
<p>comparison call
- fig=None, ax=None -&gt; plot_cycle_graph -&gt; fig in **kwargs keys
- fig=None, ax=None -&gt; line, scatter
- line, scatter plot onto active figure, axis</p>
<p>:param x_scale: Scaling factor.
:param y_scale: Scaling factor.</p>
<p>:type x:
str
:type y:
str
:type x_scale:
float
:type y_scale:
float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         x, y,
         x_scale=None, y_scale=None,
         x_label=None, y_label=None,
         show=False,
         plot_label=None,                  # When called from a _system_takeover the plot_label and color
         color=colorscheme_one()[0],       # arguments are passed to the function, but disregarded.
         colorblind=False,
         **kwargs):
    &#34;&#34;&#34;
    System plot
    -----------

    x and y are the stream parameters to be
    plotted for each stream.

    Process
    1. Create figure
    2. Create state variable and plotters vectors
        2.1 Parent connectors
    3. comparison call

    comparison call
        - fig=None, ax=None -&gt; plot_cycle_graph -&gt; fig in **kwargs keys
            - fig=None, ax=None -&gt; line, scatter
                - line, scatter plot onto active figure, axis

    :param x_scale: Scaling factor.
    :param y_scale: Scaling factor.

    :type x:        str
    :type y:        str
    :type x_scale:  float
    :type y_scale:  float
    &#34;&#34;&#34;
    plotters   = []
    x_system   = []
    y_system   = []

    defaults   = {&#39;legend&#39;: kwargs.pop(&#39;legend&#39;, True)}

    scales     = {&#39;t0&#39;: 1,
                  &#39;p0&#39;: 1/1000,
                  &#39;V&#39;:  1,
                  &#39;S&#39;:  1/1000,
                  &#39;H&#39;:  1/1000}
    x_scale    = scales[x] if isinstance(x_scale, type(None)) else x_scale
    y_scale    = scales[y] if isinstance(y_scale, type(None)) else y_scale

    # 1. Create figure
    figure((9, 5))

    # 2. Create state variable and plotters vectors
    for stream in self.streams:

        # Plot defaults
        subplot_defaults = {
            &#39;plot_label&#39;: f&#39;{&#34;.&#34;.join([str(c) for c in stream.stream_id])}&#39;,
            &#39;x_label&#39;: x_label,
            &#39;y_label&#39;: y_label,
            &#39;color&#39;: colorscheme_one()[self.streams.index(stream)],
            &#39;zorder&#39;: self.streams.index(stream),
        }

        if colorblind:
            m      = markers(hollow=True)
            marker = m[self.streams.index(stream)]
            subplot_defaults = {**subplot_defaults, **marker}

        def gen_plotter(**defaults):
            &#34;&#34;&#34;
            Returns a plotter using the defaults.
            Any keyword arguemnts passed to the
            _plot function overwrite the defaults.
            &#34;&#34;&#34;
            return lambda x, y, **kwargs: stream.plot_cycle_graph(x=x, y=y, **{**defaults, **kwargs})

        x_stream = getattr(stream, x)()*x_scale
        y_stream = getattr(stream, y)()*y_scale

        plotters.append(gen_plotter(**subplot_defaults))
        x_system.append(x_stream)
        y_system.append(y_stream)

        # 2.1 Parent connectors
        if hasattr(stream, &#39;parents&#39;):
            for parent in stream.parents:
                x_parent = getattr(parent, x)()*x_scale
                y_parent = getattr(parent, y)()*y_scale
                # If the parent stream has no stages, get parent stream&#39;s gas state
                p_x = x_parent[-1] if len(x_parent) != 0 else getattr(parent.gas, x)*x_scale
                p_y = y_parent[-1] if len(y_parent) != 0 else getattr(parent.gas, y)*y_scale
                # Connector
                if len(stream.components) &gt; 0:
                    x_system.append(np.array([p_x, x_stream[0]]))
                    y_system.append(np.array([p_y, y_stream[0]]))

                    connector_args = {&#39;color&#39;: subplot_defaults[&#39;color&#39;],
                                      &#39;zorder&#39;: self.streams.index(stream),
                                      &#39;plot_label&#39;: None,
                                      &#39;x_label&#39;: None,
                                      &#39;y_label&#39;: None,
                                      &#39;marker&#39;: &#39;&#39;
                                      }

                    if colorblind:
                        connector_args = {**connector_args}

                    plotters.append(gen_plotter(**connector_args))

    # 2.2 Remove streams with no stages
    mask_x = np.array([a.size != 0 for a in x_system])
    mask_y = np.array([a.size != 0 for a in y_system])
    mask = mask_x * mask_y  # Ensure that any x-y array pairs with an empty array are removed

    x_system = np.array(x_system, dtype=&#39;object&#39;)[mask].tolist()
    y_system = np.array(y_system, dtype=&#39;object&#39;)[mask].tolist()
    plotters = np.array(plotters, dtype=&#39;object&#39;)[mask].tolist()

    # 4. comparison call
    #     - fig=None, ax=None -&gt; plot_cycle_graph -&gt; fig in **kwargs keys
    #         - fig=None, ax=None -&gt; line, scatter
    #             - line, scatter plot onto active figure, axis
    comparison(x=x_system,
               y=y_system,
               f=plotters,
               legend_loc=(0.865, 0.425),
               autocolor=False,
               show=show,
               **{**kwargs, **defaults})</code></pre>
</details>
</dd>
<dt id="huracan.engine.system.plot_H_p"><code class="name flex">
<span>def <span class="ident">plot_H_p</span></span>(<span>self, show=False, plot_label=None, color='darkred', colorblind=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Pressure-Enthalpy system plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_H_p(self,
             show=False,
             plot_label=None,
             color=colorscheme_one()[0],
             colorblind=False,
             **kwargs):
    &#34;&#34;&#34;
    Pressure-Enthalpy system plot.
    &#34;&#34;&#34;
    args = locals()
    args.pop(&#39;self&#39;, None)
    args.pop(&#39;kwargs&#39;, None)

    self.plot(x=&#39;p0&#39;, x_label=&#39;p$_0$ [kPa]&#39;,
              y=&#39;H&#39;,  y_label=&#39;H$_0$ [kJ]&#39;,
              **{**args, **kwargs})</code></pre>
</details>
</dd>
<dt id="huracan.engine.system.plot_T_S"><code class="name flex">
<span>def <span class="ident">plot_T_S</span></span>(<span>self, show=False, plot_label=None, color='darkred', colorblind=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Temperature-Entropy system plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_T_S(self,
             show=False,
             plot_label=None,
             color=colorscheme_one()[0],
             colorblind=False,
             **kwargs):
    &#34;&#34;&#34;
    Temperature-Entropy system plot.
    &#34;&#34;&#34;
    args = locals()
    args.pop(&#39;self&#39;, None)
    args.pop(&#39;kwargs&#39;, None)

    self.plot(x=&#39;S&#39;,  x_label=&#39;$\Delta$S [kJ/K]&#39;,
              y=&#39;t0&#39;, y_label=&#39;T$_0$ [K]&#39;,
              **{**args, **kwargs})</code></pre>
</details>
</dd>
<dt id="huracan.engine.system.plot_T_p"><code class="name flex">
<span>def <span class="ident">plot_T_p</span></span>(<span>self, show=False, plot_label=None, color='darkred', colorblind=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Temperature-Pressure system plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_T_p(self,
             show=False,
             plot_label=None,
             color=colorscheme_one()[0],
             colorblind=False,
             **kwargs
             ):
    &#34;&#34;&#34;
    Temperature-Pressure system plot.
    &#34;&#34;&#34;
    args = locals()
    args.pop(&#39;self&#39;, None)
    args.pop(&#39;kwargs&#39;, None)

    self.plot(x=&#39;p0&#39;, x_label=&#39;p$_0$ [kPa]&#39;,
              y=&#39;t0&#39;, y_label=&#39;T$_0$ [K]&#39;,
              **{**args, **kwargs})</code></pre>
</details>
</dd>
<dt id="huracan.engine.system.plot_p_V"><code class="name flex">
<span>def <span class="ident">plot_p_V</span></span>(<span>self, show=False, plot_label=None, color='darkred', colorblind=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Pressure-Volume system plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_p_V(self,
             show=False,
             plot_label=None,
             color=colorscheme_one()[0],
             colorblind=False,
             **kwargs):
    &#34;&#34;&#34;
    Pressure-Volume system plot.
    &#34;&#34;&#34;
    args = locals()
    args.pop(&#39;self&#39;, None)
    args.pop(&#39;kwargs&#39;, None)

    self.plot(x=&#39;V&#39;,  x_label=&#39;v$_0$ [m$^3$/n]&#39;,
              y=&#39;p0&#39;, y_label=&#39;p$_0$ [kPa]&#39;,
              **{**args, **kwargs})</code></pre>
</details>
</dd>
<dt id="huracan.engine.system.power_available"><code class="name flex">
<span>def <span class="ident">power_available</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stream available power.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def power_available(self):
    &#34;&#34;&#34;
    Stream available power.
    &#34;&#34;&#34;
    return sum([s._power_available() for s in self.streams if s not in self.parents()])</code></pre>
</details>
</dd>
<dt id="huracan.engine.system.power_jet"><code class="name flex">
<span>def <span class="ident">power_jet</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stream jet power.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def power_jet(self):
    &#34;&#34;&#34;
    Stream jet power.
    &#34;&#34;&#34;
    return sum([s._power_jet() for s in self.streams if s not in self.parents()])</code></pre>
</details>
</dd>
<dt id="huracan.engine.system.retrieve"><code class="name flex">
<span>def <span class="ident">retrieve</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve any stream component by its stage name.</p>
<p>:type item: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve(self, item):
    &#34;&#34;&#34;
    Retrieve any stream component by its stage name.

    :type item: str
    &#34;&#34;&#34;
    components = []
    for s in self.streams:
        components += s.components

    assert item in [c.stage for c in components], &#39;Specified a non-existent stage.&#39;

    for c in components:
        if c.stage == item:
            return c</code></pre>
</details>
</dd>
<dt id="huracan.engine.system.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, log=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Run stream system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, log=True):
    &#34;&#34;&#34;
    Run stream system.
    &#34;&#34;&#34;

    self.sort_streams()

    n = 0
    while not all([s.ran for s in self.streams]):
        for s in self.streams:
            if s.stream_id[0] == n:
                s._run(log)
        n += 1</code></pre>
</details>
</dd>
<dt id="huracan.engine.system.sfc"><code class="name flex">
<span>def <span class="ident">sfc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>System specific fuel consumption.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sfc(self):
    &#34;&#34;&#34;
    System specific fuel consumption.
    &#34;&#34;&#34;
    return self.fmf()/self.thrust_flow()</code></pre>
</details>
</dd>
<dt id="huracan.engine.system.sort_streams"><code class="name flex">
<span>def <span class="ident">sort_streams</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sort system streams based on their stream ID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_streams(self):
    &#34;&#34;&#34;
    Sort system streams based on their stream ID
    &#34;&#34;&#34;
    ids     = [&#39;&#39;.join(str(c) for c in stream.stream_id) for stream in self.streams]
    indexes = [float(id.replace(&#39;m&#39;, &#39;.1&#39;).replace(&#39;s&#39;, &#39;.2&#39;)) for id in ids]
    self.streams = [s for _, s in sorted(zip(indexes, self.streams))]</code></pre>
</details>
</dd>
<dt id="huracan.engine.system.thrust_flow"><code class="name flex">
<span>def <span class="ident">thrust_flow</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>System flow thrust.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thrust_flow(self):
    &#34;&#34;&#34;
    System flow thrust.
    &#34;&#34;&#34;
    return sum([s._thrust_flow() for s in self.streams if s not in self.parents()])</code></pre>
</details>
</dd>
<dt id="huracan.engine.system.thrust_prop"><code class="name flex">
<span>def <span class="ident">thrust_prop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>System propeller thrust</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thrust_prop(self):
    &#34;&#34;&#34;
    System propeller thrust
    &#34;&#34;&#34;
    return sum([s._thrust_prop() for s in self.streams])</code></pre>
</details>
</dd>
<dt id="huracan.engine.system.thrust_total"><code class="name flex">
<span>def <span class="ident">thrust_total</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>System total thrust.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thrust_total(self):
    &#34;&#34;&#34;
    System total thrust.
    &#34;&#34;&#34;
    return self.thrust_flow() + self.thrust_prop()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#huracan-engine-elements">Huracan engine elements</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="huracan" href="index.html">huracan</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="huracan.engine.SET" href="#huracan.engine.SET">SET</a></code></h4>
<ul class="">
<li><code><a title="huracan.engine.SET.superset_takeover" href="#huracan.engine.SET.superset_takeover">superset_takeover</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="huracan.engine.SUPERSET" href="#huracan.engine.SUPERSET">SUPERSET</a></code></h4>
</li>
<li>
<h4><code><a title="huracan.engine.component" href="#huracan.engine.component">component</a></code></h4>
</li>
<li>
<h4><code><a title="huracan.engine.constructor_SET" href="#huracan.engine.constructor_SET">constructor_SET</a></code></h4>
</li>
<li>
<h4><code><a title="huracan.engine.constructor_SUPERSET" href="#huracan.engine.constructor_SUPERSET">constructor_SUPERSET</a></code></h4>
</li>
<li>
<h4><code><a title="huracan.engine.shaft" href="#huracan.engine.shaft">shaft</a></code></h4>
<ul class="">
<li><code><a title="huracan.engine.shaft.electrical_plants" href="#huracan.engine.shaft.electrical_plants">electrical_plants</a></code></li>
<li><code><a title="huracan.engine.shaft.w_exerting_machinery" href="#huracan.engine.shaft.w_exerting_machinery">w_exerting_machinery</a></code></li>
<li><code><a title="huracan.engine.shaft.w_r" href="#huracan.engine.shaft.w_r">w_r</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="huracan.engine.stream" href="#huracan.engine.stream">stream</a></code></h4>
<ul class="two-column">
<li><code><a title="huracan.engine.stream.A_exit" href="#huracan.engine.stream.A_exit">A_exit</a></code></li>
<li><code><a title="huracan.engine.stream.H" href="#huracan.engine.stream.H">H</a></code></li>
<li><code><a title="huracan.engine.stream.Q_in" href="#huracan.engine.stream.Q_in">Q_in</a></code></li>
<li><code><a title="huracan.engine.stream.S" href="#huracan.engine.stream.S">S</a></code></li>
<li><code><a title="huracan.engine.stream.V" href="#huracan.engine.stream.V">V</a></code></li>
<li><code><a title="huracan.engine.stream.W_req" href="#huracan.engine.stream.W_req">W_req</a></code></li>
<li><code><a title="huracan.engine.stream.add_component" href="#huracan.engine.stream.add_component">add_component</a></code></li>
<li><code><a title="huracan.engine.stream.add_set" href="#huracan.engine.stream.add_set">add_set</a></code></li>
<li><code><a title="huracan.engine.stream.divert" href="#huracan.engine.stream.divert">divert</a></code></li>
<li><code><a title="huracan.engine.stream.efficiency_prop" href="#huracan.engine.stream.efficiency_prop">efficiency_prop</a></code></li>
<li><code><a title="huracan.engine.stream.efficiency_thermal" href="#huracan.engine.stream.efficiency_thermal">efficiency_thermal</a></code></li>
<li><code><a title="huracan.engine.stream.efficiency_total" href="#huracan.engine.stream.efficiency_total">efficiency_total</a></code></li>
<li><code><a title="huracan.engine.stream.fmf" href="#huracan.engine.stream.fmf">fmf</a></code></li>
<li><code><a title="huracan.engine.stream.fr" href="#huracan.engine.stream.fr">fr</a></code></li>
<li><code><a title="huracan.engine.stream.log" href="#huracan.engine.stream.log">log</a></code></li>
<li><code><a title="huracan.engine.stream.merge" href="#huracan.engine.stream.merge">merge</a></code></li>
<li><code><a title="huracan.engine.stream.n_instances" href="#huracan.engine.stream.n_instances">n_instances</a></code></li>
<li><code><a title="huracan.engine.stream.p0" href="#huracan.engine.stream.p0">p0</a></code></li>
<li><code><a title="huracan.engine.stream.plot_H_p" href="#huracan.engine.stream.plot_H_p">plot_H_p</a></code></li>
<li><code><a title="huracan.engine.stream.plot_T_S" href="#huracan.engine.stream.plot_T_S">plot_T_S</a></code></li>
<li><code><a title="huracan.engine.stream.plot_T_p" href="#huracan.engine.stream.plot_T_p">plot_T_p</a></code></li>
<li><code><a title="huracan.engine.stream.plot_cycle_graph" href="#huracan.engine.stream.plot_cycle_graph">plot_cycle_graph</a></code></li>
<li><code><a title="huracan.engine.stream.plot_p_V" href="#huracan.engine.stream.plot_p_V">plot_p_V</a></code></li>
<li><code><a title="huracan.engine.stream.power_available" href="#huracan.engine.stream.power_available">power_available</a></code></li>
<li><code><a title="huracan.engine.stream.power_jet" href="#huracan.engine.stream.power_jet">power_jet</a></code></li>
<li><code><a title="huracan.engine.stream.retrieve" href="#huracan.engine.stream.retrieve">retrieve</a></code></li>
<li><code><a title="huracan.engine.stream.run" href="#huracan.engine.stream.run">run</a></code></li>
<li><code><a title="huracan.engine.stream.runtime" href="#huracan.engine.stream.runtime">runtime</a></code></li>
<li><code><a title="huracan.engine.stream.sfc" href="#huracan.engine.stream.sfc">sfc</a></code></li>
<li><code><a title="huracan.engine.stream.stage_name" href="#huracan.engine.stream.stage_name">stage_name</a></code></li>
<li><code><a title="huracan.engine.stream.stages" href="#huracan.engine.stream.stages">stages</a></code></li>
<li><code><a title="huracan.engine.stream.t0" href="#huracan.engine.stream.t0">t0</a></code></li>
<li><code><a title="huracan.engine.stream.thrust_flow" href="#huracan.engine.stream.thrust_flow">thrust_flow</a></code></li>
<li><code><a title="huracan.engine.stream.thrust_prop" href="#huracan.engine.stream.thrust_prop">thrust_prop</a></code></li>
<li><code><a title="huracan.engine.stream.thrust_total" href="#huracan.engine.stream.thrust_total">thrust_total</a></code></li>
<li><code><a title="huracan.engine.stream.v_exit" href="#huracan.engine.stream.v_exit">v_exit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="huracan.engine.system" href="#huracan.engine.system">system</a></code></h4>
<ul class="two-column">
<li><code><a title="huracan.engine.system.Q_in" href="#huracan.engine.system.Q_in">Q_in</a></code></li>
<li><code><a title="huracan.engine.system.W_req" href="#huracan.engine.system.W_req">W_req</a></code></li>
<li><code><a title="huracan.engine.system.efficiency_prop" href="#huracan.engine.system.efficiency_prop">efficiency_prop</a></code></li>
<li><code><a title="huracan.engine.system.efficiency_thermal" href="#huracan.engine.system.efficiency_thermal">efficiency_thermal</a></code></li>
<li><code><a title="huracan.engine.system.efficiency_total" href="#huracan.engine.system.efficiency_total">efficiency_total</a></code></li>
<li><code><a title="huracan.engine.system.fmf" href="#huracan.engine.system.fmf">fmf</a></code></li>
<li><code><a title="huracan.engine.system.gobble" href="#huracan.engine.system.gobble">gobble</a></code></li>
<li><code><a title="huracan.engine.system.parents" href="#huracan.engine.system.parents">parents</a></code></li>
<li><code><a title="huracan.engine.system.plot" href="#huracan.engine.system.plot">plot</a></code></li>
<li><code><a title="huracan.engine.system.plot_H_p" href="#huracan.engine.system.plot_H_p">plot_H_p</a></code></li>
<li><code><a title="huracan.engine.system.plot_T_S" href="#huracan.engine.system.plot_T_S">plot_T_S</a></code></li>
<li><code><a title="huracan.engine.system.plot_T_p" href="#huracan.engine.system.plot_T_p">plot_T_p</a></code></li>
<li><code><a title="huracan.engine.system.plot_p_V" href="#huracan.engine.system.plot_p_V">plot_p_V</a></code></li>
<li><code><a title="huracan.engine.system.power_available" href="#huracan.engine.system.power_available">power_available</a></code></li>
<li><code><a title="huracan.engine.system.power_jet" href="#huracan.engine.system.power_jet">power_jet</a></code></li>
<li><code><a title="huracan.engine.system.retrieve" href="#huracan.engine.system.retrieve">retrieve</a></code></li>
<li><code><a title="huracan.engine.system.run" href="#huracan.engine.system.run">run</a></code></li>
<li><code><a title="huracan.engine.system.sfc" href="#huracan.engine.system.sfc">sfc</a></code></li>
<li><code><a title="huracan.engine.system.sort_streams" href="#huracan.engine.system.sort_streams">sort_streams</a></code></li>
<li><code><a title="huracan.engine.system.thrust_flow" href="#huracan.engine.system.thrust_flow">thrust_flow</a></code></li>
<li><code><a title="huracan.engine.system.thrust_prop" href="#huracan.engine.system.thrust_prop">thrust_prop</a></code></li>
<li><code><a title="huracan.engine.system.thrust_total" href="#huracan.engine.system.thrust_total">thrust_total</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>